<!DOCTYPE html>
<html lang="en">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="misc/ieee.css">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RISC-ViO Spec</title>
    <!--
        * sep - set equal pointer
        * st
        * lt
        * clr
        * dtp takes base address , no tags
        * io is port mapped, io ptr created using dtp rd, io-number, zero (or any other index)

        * pointer/object type tags (impl, scratch, scratch, r, w, io, do, ex, ord) specified, bits to the left impl dep, at least 2 bits reserved fort system software
        * g|g|r|w|d|s|i|c|f|lambda|11111
        
        * 'types' -> 'kinds'
        * 'values' -> 'primitives'
        * 
    -->
</head>
<body>
    <header class="col-span page-break-after">
        <div id="title" class="subtitle counter-skip" style="margin-bottom: 0;"><em>The</em></div>
        <div class="title counter-skip"><em>RISC-ViO</em></div>
        <div id="title-spec" class="subtitle counter-skip"><em>Specification</em></div>
        <h5  id="version" class="subtitle counter-skip" style="font-size: 18pt;"><em>DRAFT V0.2.4</em></h2>
        <div class="authors col-2">
        <div class="author">
            <div>Leyla Jazz Ekinci (<em>B.Sc.</em>)</div>
            <div>University of Stuttgart, IKR</div>
            <div>Stuttgart, Germany</div>
            <div>leylknci@ikr.uni-stuttgart.de</div>
        </div>
        <div class="author">
            <div>Robin Lux (<em>B.Sc.</em>)</div>
            <div>University of Stuttgart, IKR</div>
            <div>Stuttgart, Germany</div>
            <div>rbnlux@ikr.uni-stuttgart.de</div>
        </div>
        </div>
    </header>

    <h1 class="counter-skip page-break-before" style="text-align: center;">Table of Contents</h1>
    <ul id="toc" class="toc page-break-after" style="list-style-type:none; margin-left: 0;">
    </ul>

    <h1><a id="intro">Introduction</a></h1>
    <section>
        <h2><a id="motivation">Motivation</a></h2>
        <p>
            In conventional computer architectures, the system hardware has no information about the location and size of runtime level objects like structs or arrays.
            While executing machine instructions, they also cannot distinguish between handling a pointer to such objects or a primitive that by chance has the same value as the pointer.
            This lack of information makes it impossible for the hardware to do bounds checks or automatically remove unused data from system memory.
            Programming languages like C demonstrate how this can lead to problems like buffer overflows or memory leaks.<br>
            Object-oriented programming languages like Java or Python depend on their runtime to differentiate pointers from primitives and free up unused memory.
            Obviously, this improvement of reliability and security comes with a substantial tradeoff in program efficiency written in these languages.<br>
        </p>
        <p>
            To tackle these challenges, the experimental <a href="#meyer_orisc">Objective-RISC architecture</a> (O-RISC), proposes a new perspective 
            on the cooperation of hardware and software. The O-RISC architecture is the main inspiration for RISC-ViO with its core idea to lower the concept of objects from a runtime level down to ISA level. 
            For this to work an O-RISC processor always has access to information strictly identifying pointers and boundaries of objects for every instruction executed.
            This enables the enforcement of bounds checks, the protection of data from unwanted modification and garbage collection in hardware. 
            This leads to a more robust program execution without the performance impact caused by a runtime providing these features.
        </p>
        <figure>
            <figcaption>View of the different architectures on programming language level objects in memory</figcaption>
            <div style="display: flex; margin-top: 14pt; margin-bottom: 28pt;">
                <img src="svg/conv_obj_view.drawio.svg" id="svg2" style="flex: 33%; margin: 10pt; height: 20rem">
                <img src="svg/oriscv_obj_view.drawio.svg" id="svg3" style="flex: 33%; margin: 10pt; height: 20rem">
                <img src="svg/vio_obj_view.drawio.svg" id="svg4" style="flex: 33%; margin: 10pt; height: 20rem">
            </div>
            <div style="display: flex;">
                <p style="flex: 33%; margin: 10pt;">a) Conventional architectures</p>
                <p style="flex: 33%; margin: 10pt;">b) O-RISC</p>
                <p style="flex: 33%; margin: 10pt;">c) RISC-ViO</p>
            </div>
        </figure>
        <p>
            Being the nature of groundbreaking concepts, O-RISC is designed to be very cautious about its new responsibilities.
            One area where this can be easily observed is O-RISCs postulation of immutable pointers, they always reference the head of an object.
            To index across its contents, compilers are required to keep a separate data register next to the original pointer register.
            This contradicts the assumptions many compilers make of computer architectures. LLVMs <em>getelementptr</em> instruction <a href="#llvm_gep">2</a> is one example
            where they can diverge.
            This in consequence makes O-RISC unable to compile the influential C programming language, reducing the amount of programs
            being source code compatible with this architecture.
        </p>
    </section>
    <section>
        <h2><a id="goals">Design goals</a></h2>
        <p>
            As all children try to grow up to be a better version of their parents, RISC-ViO takes over O-RISCs belief in the new way of hardware-software
            cooperation, but draws its own set of conclusions:
        </p>
        <h4 style="text-indent: 0;">1. Make software more robust while keeping compatibility</h4>
        <p style="text-indent: 0;">
            RISC-ViO aims to provide the same unambiguousness and integrity of pointers as well as bounds checks of objects O-RISC provides.
            Unlike O-RISC however, RISC-ViO aims to reduce the impact on existing software to a minimum. The only changes necessary should stay 
            on the side of runtimes and operating systems. User code on programming language level should be able to stay as is while still benefiting from RISC-ViOs advantages.
        </p>
        <h4 style="text-indent: 0;">2. Make life of compilers easier</h4>
        <p style="text-indent: 0;">
            With the introduction of hardware heap management, RISC-ViO is raising the abstraction layer of memory. Consequently, the effort of lowering higher  
            programming languages to machine instructions is dramatically reduced. This opens up chances for improvements in how software is compiled. 
            We aim to strengthen these benefits without limiting the already existing capabilities of compilers.
        </p>
        <h4 style="text-indent: 0;">3. Stay true to the RISC philosophy</h4>
        <p style="text-indent: 0;">
            The benefits of robustness are worthless when they come at the cost of arbitrary execution times. That is why RISC-ViO's instructions are designed
            in such a way that they can be implemented with single-cycle latency. This keeps changes needed to conventional RISC architectures small and program
            execution stays predictable.
        </p>
        <h4 style="text-indent: 0;">4. Be an extension, not a replacement</h4>
        <p style="text-indent: 0;">
            We propose a way the RISC-V Instruction Set Architecture can be extended without limiting other extensions or future innovation.
            This way, the idea of object-based architectures can be easily explored on a wide range of processor configurations. Reaching from minimal embedded
            applications, over vector-supporting AI accelerators to state of the art multicore, superscalar CPUs. At the same time, other researchers can easily pick up ViO
            and make use of its benefits for their own purposes.
        </p>
    </section>



    <section>
    <h1><a id="base_spec">The RISC-V I' ISA</a></h1>
        <p>
            In RISC-ViO, objects are leveraged as the way to achieve the design goals outlined in the motivational chapter.
            In order to enforce the correct use of these objects and references to these objects, RISC-ViO alters the semantics of some of the instructions which are part of the RISC-V I base instruction set.
            This alteration of the RISC-V base ISA is denoted as the RISC-V I' ISA. 
        </p>
        <h2><a id="objects_devices">Objects and I/O devices</a></h2>
        <p>
            Objects are unique, bounded areas allocated in memory. 
            The defining traits of such objects are their XLEN-wide length as well as the accesses possible on these objects. 
            For this purpose, a total of three flags, 'read', 'write' and 'data only' exist for each object.
            These flags and their incurred permissions may be set or cleared in any combination using special, privileged instructions.
        </p>
        <figure style="margin-bottom: 0.5rem">
                <img src="svg/software_objects/object1.svg" style="width: 80%; margin-bottom: 0.5rem">
                <figcaption>Visualization of a pointer (pink), primitive (blue) and an object</figcaption>
            </div>
        </figure>
        <p>
            I/O devices behave similarly to objects in that they also have XLEN-wide length traits. 
            In contrast to objects, those traits are fixed by the hardware and cannot be influenced by software. 
            I/O devices implicitly have all three of the 'read', 'write' and 'data only' flags set.  
        </p>
        <figure style="margin-bottom: 0.5rem">
                <img src="svg/software_objects/object2.svg" style="width: 80%; margin-bottom: 0.5rem">
                <figcaption>Visualization of a pointer (pink), primitive (blue) and an object</figcaption>
            </div>
        </figure>
        <h2><a id="data_vs_pointers">Pointers and primitives</a></h2>
        <p>
            The RISC-V I' ISA differentiates between two data types in the register file and in memory: references to objects or I/O devices, called pointers, and regular data, being denoted as primitives.
        </p>
        <p>
            Pointers have a a total of two separate fields. One of those is a reference field containing either an objects base address or the number of a I/O device.<br>
            An objects second field always contains an index which may point to any byte inside of the referenced object or I/O device. 
            The pointer encoding has to allow pointers to cover the entire address space of the processor of XLEN bits.
        </p>
        <p>
            A value like a number or a character may be arbitrarily modified just as it is possible in RISC-V.<br>
            
        </p>
        <p>For a pointer, in contrast, some restrictions apply regarding the way in which it may be modified.
            Arithmetic or logic operations on such a pointer like additions or bitwise inversions modify the pointer as a regular address would have been modified by the executed operation. 
            This modification is achieved by only altering a pointers index field while the combined field stays unchanged. 
            Note that pointers having an index reaching out of the bounds of an object or I/O device are allowed in both the register file and in memory.
            In case of pointers of memory type, comparisons act only on the effective address of a pointer, all other information is not taken into account.
            For I/O type pointers, the value used for the actual comparison is made up by shifting the I/O device number up by XLEN bits and adding this value to the index.
            <br>
            Arithmetic or logical operations on two pointers are allowed in the case that both pointers are of memory type.
            For arithmetic operations on two memory type pointers, the combined field of the resulting pointer is chosen from the input pointer base addresses such that the calculated index lies within the object located at this base address. 
            Should the result not fall into either of the input objects, the behavior regarding which input is used for the base address field of the resulting pointer is undefined. 
        </p>

        <h2><a id="#isa_tags">Object tags</a></h2>
        <p>
            By combining the three independent access permissions of an object, a total of eight distinct combinations are possible.
            To simplify the discussion of objects, these possibilities are combined to make up three types.
        </p>
        <p>
            The first types is denoted as the regular type. Any object having its 'data only' flag cleared is of this type.
            Such objects may hold any data meaning both values and pointers may be stored in an object of this type.
            In order to enforce the separation of instructions and data however, instructions may not be fetched from such objects and executed afterwards.
        </p>
        <p>
            The second important object type is objects having their 'data only' flag set and at least one of their 'read' or 'write' flags being enabled.
            Such objects are said to be data only objects.
            Data only objects, unlike regular objects, may not contain pointers.
            Just as with regular objects, it is not allowed to fetch and execute instructions from such objects.
            By keeping pointers out of data only objects, it is possible to achieve an improvement of memory access efficiency in some implementations.
            Another advantage of objects not containing any pointers is the reduction of the effort caused by garbage collecting these objects.
        </p>
        <p>
            As hinted at by the section on regular objects, there is also an object type which contains instructions.
            This object type is denoted as 'executable' and has its 'data only' flag set while both 'read' and 'write' flags are cleared.
            As such, no instruction may explicitly access the contents of an object of this type. Only the processor may implicitly read from executable objects to fetch instructions.
            This makes it necessary for system management software to load in code in the form of a data only object and then alter object type by modifying its permission flags.
            RISC-ViO requires executable objects to hold a pointer to their Global Offset Table as described in the <a href="#got">Global Offset Table</a> chapter. 
            In user mode, this pointer is not accessible directly but has to be setup by the system management software instead.
        </p>   

        <h2><a id="riscv_i_tick">RISC-V I vs I'</a></h2>
        <p>
        For the differentiation between pointers and values to be meaningful, RISC-ViO mandates that only pointers may be used to access memory via the object abstraction. The same is also true for accesses to I/O devices: Accesses to I/O devices is only possible via their corresponding pointer.
        <!--For obtaining pointers, there are two distinct possibilities. Either by using a member the alc instruction family to allocate a new object or by manually creating them in higher privilege modes. -->
        (Note that pointers may not be written to I/O devices as their 'data only' flag is set implicitly.)
        This requirement influences all load and store instructions as listed below:
        </p>
        <ul style="list-style-position: inside; padding-left: 0; text-align:center">
            <li style="display: inline; padding-right: 2em;">◈ lb/lbu</li>
            <li style="display: inline; padding-right: 2em;">◈ lh/lhu</li>
            <li style="display: inline; padding-right: 2em;">◈ lw</li>
            <li style="display: inline; padding-right: 2em;">◈ sb</li>
            <li style="display: inline; padding-right: 2em;">◈ sh</li>
            <li style="display: inline; padding-right: 2em;">◈ sw</li>
        </ul>

        <p>
         The main change for those instruction families lies in them requiring pointers to be used to select objects and I/O devices instead of memory locations.
        Offsets from those pointers using the 12 bit immediate present in those instructions are still allowed. 
        Those offsets are added to the index of the pointer used to access the object to make up the offset used for the actual object or I/O device access.
        Being explicit memory accesses in the case of memory type pointers, these instructions may only access regular as well as data only objects.</p>
        <!--@Leyla: wenn man unsere regeln bricht, tritt eine hardware exception-->
        <p>
        </p>
        <!--@Leyla: Bild erstellen!-->
        <p>
        Since instructions are managed using executable objects, the semantics of even more instructions have to be altered: 
        </p>
        <ul style="list-style-position: inside; padding-left: 0; text-align:center">
            <li style="display: inline; padding-right: 2em;">◈ auipc</li>
            <li style="display: inline; padding-right: 2em;">◈ jalr</li>
            <li style="display: inline; padding-right: 2em;">◈ jal</li>
        </ul>
        <p>
        The <em>auipc</em> instruction for example will emit a pointer instead of a value. 
        Due to the access to executable objects being limited as described in the <a href="#objs_execs">executable objects</a> chapter however, access to constant data is not possible using  this pointer.
        </p>
        <p>
        The encapsulation of instructions also means that the <em>jalr</em> instructions expects a pointer to a object containing instructions as a jump target to be written to the program counter.
        This instruction will also, just as <em>jal</em> does, write a pointer to its destination register.
        <!--If the pointer provided does not reference such an object, the processor raises a <em>IncompatibleTypeException</em> with <em>xtval</em> containing the target pointer.-->
        For the separation of data and instructions, <em>jalr</em> also requires a pointer to an executable object as source register content.
        Using a value as a destination for <em>jalr</em> is still allowed though and leads to jumping to the given index inside the currently executed executable object.
        To make sure that a return address cannot be used twice, RISC-ViO mandates that the variant of <em>jalr</em> which realizes the <em>ret</em> pseudoinstruction has to null out the register <em>ra</em> except for the zero-bit of its index after updating the program counter.
        </p>

        <h2><a id="riscv_i_tick">Register file</a></h2>
            </p>
            RISC-V specifies 31 general-purpose registers and one special register, <em>zero</em>.
            The RISC-ViO architecture adds additional requirements to this register file definition:
                <ul>
                    <li>each register has to be able to hold either a value of width XLEN or a pointer with a XLEN wide index.</li>
                    <li>both <em>ra</em> and <em>sp</em> have to be able to hold colour information. (see <a href="#frames">frames</a> chapter)</li>
                </ul>
            <div style="font-size: 10pt;">Note: The <em>zero</em> register has to contain the value 0.</div>
            <p>
        </p>
    </section>




    <section>
    <h1><a id="instructions">The zhm extension</a></h1>
        <p>In addition to the modifications of already existing instructions which are part of the RISC-V I base ISA, RISC-ViO introduces several instructions as an interface between software and hardware regarding objects.
            Those instructions are all part of the zhm ("heap management") extension.
        </p>

        <h2><a name="unpriv_instructions">Unprivileged instructions</a></h2>
        <h3><a name="alc_fam">Allocation: alc/alci/alc.d/alci.d</a></h3>
        <p>
            Since RISC-ViO manages objects on the ISA level, the ISA has to provide a means to create new objects and their corresponding pointers.
            The creation of ISA level objects on the heap is achieved by the alc-instruction family which comes in four flavours. 
            In fact the alc instruction family is the only way to obtain new pointers in user mode.
            The next section provides a short description of those instructions alongside their bit encodings.
            The objects allocated by the alc-instruction family are both readable and writable but not executable on allocation (their 'read' and 'write' bits are set). 
            Newly allocated objects only contain the primitive value 0.
        </p>
        <p>
            In order for the system management software to influence where new objects are placed, the zhm extension introduces an additional machine mode CSR.
            The CSR <em>malc</em> contains both the lowest possible address on the heap as well as the address of the object last allocated.
            Those values are represented using a pointer, where the base address field contains the address of the object last allocated and the index field contains the lowest address still being part of the heap.
            The CSR index of the <em>malc</em> CSR can be extracted from the <a href="#t_csr">CSR table</a>.
        </p>

        <h4><a name="alc">alc-instruction</a></h4>
            The <em>alc</em> instruction is the most basic form in its family. This instruction allows the allocation of a regular object where the size of the object is by the value passed via rs1.
            The size is given in bytes as per the value in rs1.
            
            <div style="margin-top: 5%; margin-bottom: 3%;">
                <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                    <colgroup>
                        <col width="20%"/>
                        <col width="13%"/>
                        <col width="14%"/>
                        <col width="8%"/>
                        <col width="14%"/>
                        <col width="20%"/>
                    </colgroup>
                    <thead>
                        <th style="border-style:solid; border-width: 0px;">
                                <div style="float: left">31</div><div style="float: right">25</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">24</div><div style="float: right">20</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">19</div><div style="float: right">15</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">14</div><div style="float: right">12</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">11</div><div style="float: right">7</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">6</div><div style="float: right">0</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            Instruction
                        </th>
                    </thead>
                    <tbody>
                        <tr  style="float: center">
                            <td>0000000</td><td>rs2 (src)</td><td>00010</td><td>000</td><td>rd (dst)</td><td>0001011</td><td>alc</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>When the <em>alc</em> instruction is used to allocate a frame by specifying <em>sp</em> as the destination register, its semantic is extended. In this case <em>alc</em> not only allocates a new frame object but also stores the old <em>sp</em> at index zero of the new frame object, making it the only field in the frame object which is not of primitive 0 value</p>
        The alc instruction may trigger the following exceptions for the given events (xtval content):
        <ul>
            <li><em>HeapOverflowException</em>: Allocating the specified object would overflow the heap. (object_size as value)</li>
            <li><em>IncompatibleTypeException</em>: rs2 contains a pointer, not a value (rs2)</li>
            <li><em>GPAccessException</em>: rd is forbidden gp (-)</li>
        </ul>

        <h4><a name="alci">alci-instruction</a></h4>
        The <em>alci</em> instruction is a variation of the <em>alc</em> instruction. In contrast to <em>alci</em>, the size of the new object is given by the 12 bit wide immediate. 
        This immediate specifies the amount of pointers which can fit inside the object. So for a XLEN of 32, it specifies the number of 32 bit words that fit into the object.
        <div style="margin-top: 5%; margin-bottom: 3%;">
            <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                <colgroup>
                    <col width="20%"/>
                    <col width="13%"/>
                    <col width="14%"/>
                    <col width="8%"/>
                    <col width="14%"/>
                    <col width="20%"/>
                </colgroup>
                <thead>
                    <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">31</div><div style="float: right">25</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">24</div><div style="float: right">20</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">19</div><div style="float: right">15</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">14</div><div style="float: right">12</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">11</div><div style="float: right">7</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">6</div><div style="float: right">0</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        Instruction
                    </th>
                </thead>
                <tbody>
                    <tr  style="float: center"></tr>
                        <td colspan="2">imm[13:2]</td><td>00010</td><td>010</td><td>rd (dst)</td><td>0001011</td><td>alci</td>
                    </tr>
                </tbody>
            </table>
        </div>
        <p>Please note that the <em>alci</em> instruction behaves the same way <em>alc</em> does when rd is <em>sp</em>.</p>
        The <em>alci</em> instruction may trigger the following exceptions for the given events (xtval content):
        <ul>
            <li><em>HeapOverflowException</em>: Allocating the specified object would overflow the heap. (object_size as value)</li>
            <li><em>GPAccessException</em>: rd is forbidden gp (-)</li>
        </ul>

        <h4><a name="alcd">alc.d-instruction</a></h4>
            The <em>alc.d</em> instruction is a specialization of the <em>alc</em> instruction, allowing for the allocation of data only objects.
            Note that is it also forbidden to use <em>alc.d</em> to allocate a new frame object.
            <div style="margin-top: 5%; margin-bottom: 3%;">
                <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                    <colgroup>
                        <col width="20%"/>
                        <col width="13%"/>
                        <col width="14%"/>
                        <col width="8%"/>
                        <col width="14%"/>
                        <col width="20%"/>
                    </colgroup>
                    <thead>
                        <th style="border-style:solid; border-width: 0px;">
                                <div style="float: left">31</div><div style="float: right">25</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">24</div><div style="float: right">20</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">19</div><div style="float: right">15</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">14</div><div style="float: right">12</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">11</div><div style="float: right">7</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">6</div><div style="float: right">0</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            Instruction
                        </th>
                    </thead>
                    <tbody>
                        <tr  style="float: center"></tr>
                            <td>0000000</td><td>rs2 (src)</td><td>00000</td><td>001</td><td>rd (dst)</td><td>0001011</td><td>alc.d</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        The <em>alc.d</em> instruction may trigger the following exceptions for the given events (xtval content):
        <ul>
            <li><em>HeapOverflowException</em>: Allocating the specified object would overflow the heap. (object_size as value)</li>
            <li><em>IncompatibleTypeException</em>: rs2 contains a pointer, not a value (rs2)</li>
            <li><em>ForbiddenDstException</em>: rd is forbidden sp (-)</li>
            <li><em>GPAccessException</em>: rd is forbidden gp (-)</li>
        </ul>

        <h4><a name="alcid">alci.d-instruction</a></h4>
        The <em>alci.d</em> instruction is the analogous form of <em>alci</em> regarding data only objects. It differs in the type of allocated object and in that it also is prohibited from allocating frames.
        <div style="margin-top: 5%; margin-bottom: 3%;">
            <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                <colgroup>
                    <col width="20%"/>
                    <col width="13%"/>
                    <col width="14%"/>
                    <col width="8%"/>
                    <col width="14%"/>
                    <col width="20%"/>
                </colgroup>
                <thead>
                    <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">31</div><div style="float: right">25</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">24</div><div style="float: right">20</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">19</div><div style="float: right">15</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">14</div><div style="float: right">12</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">11</div><div style="float: right">7</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">6</div><div style="float: right">0</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        Instruction
                    </th>
                </thead>
                <tbody>
                    <tr  style="float: center"></tr>
                        <td colspan="2">imm[13:2]</td><td>00000</td><td>011</td><td>rd (dst)</td><td>0001011</td><td>alci.d</td>
                    </tr>
                </tbody>
            </table>
        </div>
        The <em>alci.d</em> instruction may trigger the following exceptions for the given events (xtval content):
        <ul>
            <li><em>HeapOverflowException</em>: Allocating the specified object would overflow the heap. (object_size as value)</li>
            <li><em>ForbiddenDstException</em>: rd is forbidden sp (-)</li>
            <li><em>GPAccessException</em>: rd is forbidden gp (-)</li>
        </ul>
        <h3><a name="qsz">Attribute query: qsz</a></h3>
        The <em>qsz</em> instruction provides a means of reading an objects size as specified at its allocation time in bytes. For this, the source register has to contain a pointer.
        <div style="margin-top: 5%; margin-bottom: 3%;">
            <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                <colgroup>
                    <col width="20%"/>
                    <col width="13%"/>
                    <col width="14%"/>
                    <col width="8%"/>
                    <col width="14%"/>
                    <col width="20%"/>
                </colgroup>
                <thead>
                    <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">31</div><div style="float: right">25</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">24</div><div style="float: right">20</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">19</div><div style="float: right">15</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">14</div><div style="float: right">12</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">11</div><div style="float: right">7</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">6</div><div style="float: right">0</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        Instruction
                    </th>
                </thead>
                <tbody>
                    <tr  style="float: center"></tr>
                        <td>0000000</td><td>00000</td><td>rs1 (src)</td><td>100</td><td>rd (dst)</td><td>0001011</td><td>qsz</td>
                    </tr>
                </tbody>
            </table>
        </div>
        The <em>qsz</em> instruction may trigger the following exceptions for the given events (xtval content):
        <ul>
            <li><em>IncompatibleTypeException</em>: rs1 contains a pointer, not a value (rs1)</li>
            <li><em>ForbiddenDstException</em>: rd is sp which only takes pointers (-)</li>
            <li><em>GPAccessException</em>: rd is forbidden gp (-)</li>
        </ul>
        <h2><a name="priv_instructions">Privileged Instructions</a></h2>
            With the instructions described above, it is impossible to break out of the restrictions given by the bounds check and pointer integrity safety measures. It is also not possible to influence object behaviour regarding permissions.
            To enable the management of the processor system, requiring low level control over these features, additional instructions are available for all privilege modes above the user mode.
        <h3><a name="dtp">Raw pointer access: sep/btd/itd/dtp</a></h3>
            In order to be able to create and inspect pointers a total of four instructions are provided. These allow for asserting that a register contains a pointer, reading out the integral parts of a pointer as well as creating arbitrary pointers.
            <h4><a name="sep">sep-instruction</a></h4>
            The <em>sep</em> 'set if pointer' instruction allows for checking for the kind of value present in a register. When the register given by rs1 contains a primitive, a primitive of value 0 is written into the register given by rd.
            Otherwise, a non 0 primitive value is written to this register.
            <div style="margin-top: 5%; margin-bottom: 3%;">
                <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                    <colgroup>
                        <col width="20%"/>
                        <col width="13%"/>
                        <col width="14%"/>
                        <col width="8%"/>
                        <col width="14%"/>
                        <col width="20%"/>
                    </colgroup>
                    <thead>
                        <th style="border-style:solid; border-width: 0px;">
                                <div style="float: left">31</div><div style="float: right">25</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">24</div><div style="float: right">20</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">19</div><div style="float: right">15</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">14</div><div style="float: right">12</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">11</div><div style="float: right">7</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">6</div><div style="float: right">0</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            Instruction
                        </th>
                    </thead>
                    <tbody>
                        <tr  style="float: center"></tr>
                        <td>1111110</td><td>00000</td><td>rs1(ptr)</td><td>000</td><td>rd(tag)</td><td>0001011</td><td>sep</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <h4><a name="btd">btd-instruction</a></h4>
            The btd 'base to data' instruction allows for reading out a pointers raw pointer value. This value is written into rd for the pointer given in rs1.
            <div style="margin-top: 5%; margin-bottom: 3%;">
                <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                    <colgroup>
                        <col width="20%"/>
                        <col width="13%"/>
                        <col width="14%"/>
                        <col width="8%"/>
                        <col width="14%"/>
                        <col width="20%"/>
                    </colgroup>
                    <thead>
                        <th style="border-style:solid; border-width: 0px;">
                                <div style="float: left">31</div><div style="float: right">25</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">24</div><div style="float: right">20</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">19</div><div style="float: right">15</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">14</div><div style="float: right">12</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">11</div><div style="float: right">7</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">6</div><div style="float: right">0</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            Instruction
                        </th>
                    </thead>
                    <tbody>
                        <tr  style="float: center"></tr>
                            <td>1101111</td><td>00000</td><td>rs1(ptr)</td><td>000</td><td>rd(dst)</td><td>1001001</td><td>btd</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            The <em>btd</em> instruction may trigger the following exceptions for the given events (xtval content):
            <ul>
                <li><em>IncompatibleTypeException</em>: rs1 contains a value, not a pointer (rs1)</li>
            </ul>
            <h4><a name="itd">itd-instruction</a></h4>
            The <em>itd</em> 'index to data' instruction allows for reading out a pointers raw pointer index. This value is written into rd for the pointer given in rs1.
            <div style="margin-top: 5%; margin-bottom: 3%;">
                <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                    <colgroup>
                        <col width="20%"/>
                        <col width="13%"/>
                        <col width="14%"/>
                        <col width="8%"/>
                        <col width="14%"/>
                        <col width="20%"/>
                    </colgroup>
                    <thead>
                        <th style="border-style:solid; border-width: 0px;">
                                <div style="float: left">31</div><div style="float: right">25</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">24</div><div style="float: right">20</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">19</div><div style="float: right">15</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">14</div><div style="float: right">12</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">11</div><div style="float: right">7</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">6</div><div style="float: right">0</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            Instruction
                        </th>
                    </thead>
                    <tbody>
                        <tr  style="float: center"></tr>
                            <td>1011111</td><td>00000</td><td>rs1 (ptr)</td><td>000</td><td>rd (dst)</td><td>1001001</td><td>itd</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <h4><a name="dtp">dtp-instruction</a></h4>
            The dtp 'data to pointer' instruction allows for the assembly of arbitrary pointers. Both the index as well as the base address are set according the values in registers rs1 and rs2 respectively. The result is stored in rd. 
            Pointers assembled using <em>dtp</em> are of memory object type on creation but may be turned into I/O pointers using the <em>st</em> instruction. Note that in such a case, the I/O device number field is directly set to base address field value. 
            <div style="margin-top: 5%; margin-bottom: 3%;">
                <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                    <colgroup>
                        <col width="20%"/>
                        <col width="13%"/>
                        <col width="14%"/>
                        <col width="8%"/>
                        <col width="14%"/>
                        <col width="20%"/>
                    </colgroup>
                    <thead>
                        <th style="border-style:solid; border-width: 0px;">
                                <div style="float: left">31</div><div style="float: right">25</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">24</div><div style="float: right">20</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">19</div><div style="float: right">15</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">14</div><div style="float: right">12</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">11</div><div style="float: right">7</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">6</div><div style="float: right">0</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            Instruction
                        </th>
                    </thead>
                    <tbody>
                        <tr  style="float: center"></tr>
                            <td>0111111</td><td>rs2 (ix)</td><td>rs1 (base)</td><td>000</td><td>rd (dst)</td><td>1001001</td><td>dtp</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            The <em>dtp</em> instruction may trigger the following exceptions for the given events (xtval content):
            <ul>
                <li><em>IncompatibleTypeException</em>: rs1 or rs2 contains a pointer, not a value (rs1 or rs2 with rs1 being prioritized)</li>
            </ul>
        <h3><a name="lt_st">Object tag access: lt/st</a></h3>
            In order for a system software to gain control over the tags that make up an objects traits, additional instructions are required. Both read and write access to these tags is possible using the instructions introduced below. 
            <h4><a name="lt">lt-instruction</a></h4>
            The <em>lt</em> instruction enables reading out the tags of an object by placing the tags of the object or I/O device pointed to by the contents of rs1 into the register rd in the form of a primitive. 
            For information on how these tags are encoded, please refer to the discussion of <a href="#isa_tags">tags on ISA level</a>.
            <div style="margin-top: 5%; margin-bottom: 3%;">
                <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                    <colgroup>
                        <col width="20%"/>
                        <col width="13%"/>
                        <col width="14%"/>
                        <col width="8%"/>
                        <col width="14%"/>
                        <col width="20%"/>
                    </colgroup>
                    <thead>
                        <th style="border-style:solid; border-width: 0px;">
                                <div style="float: left">31</div><div style="float: right">25</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">24</div><div style="float: right">20</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">19</div><div style="float: right">15</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">14</div><div style="float: right">12</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">11</div><div style="float: right">7</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">6</div><div style="float: right">0</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            Instruction
                        </th>
                    </thead>
                    <tbody>
                        <tr  style="float: center"></tr>
                            <td>1110111</td><td>00000</td><td>rs1 (ptr)</td><td>000</td><td>rd (tags)</td><td>1001001</td><td>lt</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            The <em>lt</em> instruction may trigger the following exceptions for the given events (xtval content):
            <ul>
                <li><em>IncompatibleTypeException</em>: rs1 contains a value, not a pointer (rs1)</li>
            </ul>
            <h4><a name="st">st-instruction</a></h4>
            The <em>st</em> instruction is the companion of the <em>lt</em> instruction, allowing object or I/O device tags to written. For this, <em>st</em> sets the tags of the object or I/O device being referenced by the content of the rs1 register to the tags provided in rs2 in form of a primitive.
            
            <div style="margin-top: 5%; margin-bottom: 3%;">
                <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                    <colgroup>
                        <col width="20%"/>
                        <col width="13%"/>
                        <col width="14%"/>
                        <col width="8%"/>
                        <col width="14%"/>
                        <col width="20%"/>
                    </colgroup>
                    <thead>
                        <th style="border-style:solid; border-width: 0px;">
                                <div style="float: left">31</div><div style="float: right">25</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">24</div><div style="float: right">20</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">19</div><div style="float: right">15</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">14</div><div style="float: right">12</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">11</div><div style="float: right">7</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">6</div><div style="float: right">0</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            Instruction
                        </th>
                    </thead>
                    <tbody>
                        <tr  style="float: center"></tr>
                            <td>1111011</td><td>rs2 (sd)</td><td>rs1 (ptr)</td><td>000</td><td>00000</td><td>0001011</td><td>st</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            The <em>st</em> instruction may trigger the following exceptions for the given events (xtval content):
            <ol>
                <li><em>IncompatibleTypeException</em>: rs1 contains a primitive, not a pointer (rs1)</li>
                <li><em>IncompatibleTypeException</em>: rs2 contains a pointer, not a primitive (rs2)</li>
            </ol>
            <h4><a name="st">st-instruction</a></h4>
            The <em>st</em> instruction is the companion of the <em>lt</em> instruction, allowing object or I/O device tags to written. For this, <em>st</em> sets the tags of the object or I/O device being referenced by the content of the rs1 register to the tags provided in rs2 in form of a primitive.
            
            <h3><a name="clr">Memory clearing: clr</a></h3>
            <p>
                In order to be able for garbage collection to be possible in software, it is necessary to be able to clear out certain memory regions. 
                This is a consequence of mandating that newly allocated objects may only contain the primitive value 0. 
                A garbage collector implemented in software is able to use the <em>clr</em> instruction to ensure that this requirement is met.
                This is achieved by this instruction writing the primitive value 0 of XLEN width to the memory address given by the contents of register rs1.
            </p>
            <div style="margin-top: 5%; margin-bottom: 3%;">
                <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                    <colgroup>
                        <col width="20%"/>
                        <col width="13%"/>
                        <col width="14%"/>
                        <col width="8%"/>
                        <col width="14%"/>
                        <col width="20%"/>
                    </colgroup>
                    <thead>
                        <th style="border-style:solid; border-width: 0px;">
                                <div style="float: left">31</div><div style="float: right">25</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">24</div><div style="float: right">20</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">19</div><div style="float: right">15</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">14</div><div style="float: right">12</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">11</div><div style="float: right">7</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">6</div><div style="float: right">0</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            Instruction
                        </th>
                    </thead>
                    <tbody>
                        <tr  style="float: center"></tr>
                            <td>1111101</td><td>00000</td><td>rs1(ptr)</td><td>000</td><td>00000</td><td>0001011</td><td>clr</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            The <em>clr</em> instruction may trigger the following exceptions for the given events (xtval content):
            <ul>
                <li><em>IncompatibleTypeException</em>: rs1 contains a pointer, not a primitive (rs1)</li>
            </ul>
    </section>
    
    <h1><a id="frames">The not so stacked frames</a></h1>
        <p>In order to protect the local data as well as control flow data of a function, RISC-ViO alters the concept of what is called a stack in conventional architectures.
            To protect the stand-ins for this stack, the so-called frame objects or frames, from malicious or accidental modification by foreign functions, RISC-ViO introduces additional protection mechanisms for these frame objects.</p>
        <!--@Leyla: Linked Frames-->
                <p>
        Apart from objects for regular data storage the I' ISA also manages the stack as a series of objects. This partition of the stack in a single frame per function allows for further security mechanisms but also requires cooperation by the program.
        Most notably, the stack is not grown by arithmetically modifying the stack pointer. Instead, the program has to manually allocate a new frame object. Once this frame object has been allocated, accesses to inside this object behave just the way the stack frame in RISC-V behaves.<br>
        Due to the stack pointer register now containing a pointer, I' is able to protect older frame objects from accesses by arithmetical modification of sp.
        The implications for the passing of function arguments between functions are outlined in the <a href="#chap_calling_convention">calling convention</a> chapter.
        </p>
        <h2><a id="are_obj">Structure</a></h2>
            <p>
                Frame objects are based on regular objects but differ in the accesses which are allowed on them. 
                Frame objects are never data only which means the 'data only' flag is cleared. 
                To protect both the stack pointer <em>sp</em> as well as the return index <em>ra</em>, in frame objects special slots are reserved. For the 'stack' pointer <em>sp</em>, the pointer to the previous frame object, the first slot of XLEN size at byte index zero is reserved. 
                This is immediately followed by the <em>ra</em> slot which is also XLEN wide. For XLEN=32, this slot resides at byte address 4.
                In user mode, these slots of a frame object are only allowed to be used to store or load their respective register. Any other operation on these slots will lead to a <em>ForbiddenDstException</em> or <em>ForbiddenSrcException</em>.
                Note that it is not only prohibited to store any other register than <em>sp</em> and <em>ra</em> in those slots, but also to store these registers anywhere else when in not in a privileged mode. The same restriction also applies when loading these registers.
                These restrictions are enforced using <em>ForbiddenDstException</em> and <em>ForbiddenSrcException</em>.
                <figure style="display:flex; margin-bottom: 0.5rem">
                    <div style="flex: 30%; margin-bottom: 0.5rem">
                        <figcaption>A Frame Object for XLEN=32</figcaption>
                        <img src="svg/objektbaukasten/frame_object.svg" id="frame_object_svg" style="width: 35%;margin-bottom: 0.5rem">
                    </div>
                </figure>
                All other slots are general purpose and access to them is not restricted in any way.
            </p>
        <h2><a id="chap_calling_convention">Calling convention</a></h2>
            <p>As described in the introduction to this chapter, RISC-ViO denies foreign access to frame objects. As a consequence, the calling convention has be modified slightly from the convention used by RISC-V.
                Namely, it is not possible to spill function arguments from registers onto the stack of the receiving function. Instead, the following scheme is employed: 
                Just as is the case for conventional RISC-V, the arguments are stored in the registers <em>a0</em> to <em>a7</em> given that there are no more than eight XLEN arguments or as many arguments as will fit in those registers.
                Instead of pushing the additional arguments that will not fit in the argument registers on the stack, a spill object of corresponding size has to be allocated. A pointer to this spill object is placed in <em>a7</em> and the remaining arguments are stored in this object.
            </p>
        <section>
            <h2><a id="frame_ownership">Frame ownership</a></h2>
                <p>
                    To achieve protection of frames from foreign accesses RISC-ViO uses so-called colour tags for both the <em>sp</em> and the <em>ra</em> register.
                    By updating those colours at critical points such as function entries/exits and frame allocations, the processor always knows whether the frame pointed to by the
                    <em>sp</em> register is owned by the currently executed function. 
                    This state is called "regular", while the current function not being the owner of the current frame is denoted as the "irregular" state.
                </p>
                <p>For <em>sp</em> as well as for <em>ra</em>, there are two colours: black and white. Those colours are an integral part of those registers and cannot be read or modified separately from their registers.
                    Also, when storing/loading <em>ra</em> and <em>sp</em> using <em>sw/lw</em>, their colour is also stored/retrieved to/from their slots.
                    An overview of the transition between those colours is given in Figure 1.
                    On every function entry, signified by a <em>jalr ra, zero, x (call)</em> instruction, the processor flips the colour of ra from white to black or vice versa. The same also happens when a function is exited using <em>jalr zero, ra, 0 (ret)</em>. For <em>sp</em>, this takes place on every frame allocation using the <em>alc/alci</em> instructions.
                    Whether the processor is currently in the regular state (light blue), is given by the equality of the colours of ra and sp. 
                    If the colours of <em>sp</em> and <em>ra</em> both were black for example, the processor would be in the regular state, allowing access to the current frame.
                </p>
            <figure>
                <figcaption>Colour transitions</figcaption>
                <div style="width: 100%; display: flex; justify-content: center;">
                    <div style="width: 80%; display: flex; justify-content: space-around; flex-direction: row;  flex-wrap: wrap;">
                        <div style="margin: 0px auto" >
                            <img src="svg/vio_stack_colors_transitions.drawio.svg" id="svg2" style="width: 20rem; margin: 0px auto;">
                        </div>
                    </div>
                </div>
            </figure>
                <p>
                    Figure 2 provides two sample program flows for which the colour and therefore state transitions are shown. 
                    Figure 2a) shows the behaviour of the colour mechanism during the execution of a correct stream of instructions while figure 2b) highlights how this mechanism catches bad program behaviour. 
                    In 2b) the colour mechanism spots function b trying to access function a's frame, which leads to the processor raising a <em>StateException</em>.
                </p>
            <figure>
                <figcaption>State transitions two instruction streams</figcaption>
                <div style="display: flex; margin-top: 14pt; margin-bottom: 28pt;">
                    <img src="svg/vio_stack_colors.drawio.svg" id="svg1" style="flex: 50%; margin-right: 10pt;">
                    <img src="svg/vio_stack_colors_exception.drawio.svg" id="svg2" style="flex: 50%; margin-left: 10pt; align-self: baseline;">
                </div>
                <div style="display: flex;">
                    <p style="flex: 50%; margin-right: 10pt;">a) Transitions during normal program flow</p>
                    <p style="flex: 50%; margin-left: 10pt;">b) Transitions during abnormal program flow with exception</p>
                </div>
            </figure>
        </section>
    
        <section>   
    <h1><a id="got">Global offset table</a></h1>
    <p><i>Der Einsatz von Code-Objekten verbietet Sprünge auf fest definierte Adressen. Auch Speichern und Laden von Daten an festen Adressen ist mit dem Objektansatz unvereinbar.
        In herkömlichen Architekturen kommen zum Auflösen von (zur Compilezeit) unbekannten Adressen "Global Offset Tables" (GOT) zum Einsatz. Möchte ein Programm auf bestimmte Runtime-Funktionen
        wie z.B. printf() zugreifen, kompilieren gcc und clang keinen Sprung zu einer absoluten Adresse in den Programmablauf, sondern einen Sprung in die für dieses Programm individulle GOT.
        Die GOT wird dann wenn das Programm geladen wird vom Betriebssystem gefüllt, sodass diese den Sprung an die richtige Stelle in der Runtime weiterleitet. Der "Umweg" über die GOT
        dient vor allem Sicherheitstechnischen Aspekten. So kann ein Betriebssystem den Zugriff auf bestimmte Runtime Funktionen verwehren, indem es sich beim Laden des Programmes entscheidet,
        die Adresse der Funktion nicht in die GOT einzutragen. Außerdem kann das Betriebssystem die echten Adressen der Runtime-Funktionen vor dem Nutzerprogramm verstecken, indem es in die 
        GOT nicht die Endadresse sondern auf eine weitere, für das Nutzerprogramm nicht lesbare aber ausführbare, Sprungtabelle verweist.
        Neben den Sicherheitsaspekten bieten GOTs auch noch die Möglichkeit des "Lazy Linkings". Die GOT Einträge werden beim Laden des Programmes nicht auf die tatsächlichen Zieladressen,
        sondern auf die Adresse des Dynamischen Linkers gesetzt. Soll nun das erste Mal ein Bibliotheksaufruf ausgeführt werden, wird in wirklichkeit zuerst der Linker angesprungen, der
        die Adresse des Sprungziels ermittelt. Diese ersetzt dann den Eintrag in der GOT die den Linker aufgerufen hat, so dass folgende Sprünge nicht noch einmal den Linker ansprechen müssen.
    </i></p>
    <h2><a id="gp">Global pointer</a></h2>
    <p><i>In der herkömlichen RISC-V ABI wird die Adresse der GOT über die Distanz zum jal[r] Befehl angegeben. Dieser Ansatz ist in ViO nicht nutzbar, da ein Objekt nicht gleichzeitig
            lesbar und ausführbar sein kann. Zu diesem Zweck wird eine Art "companion"-Objekt eingeführt, dass alle Adressen, auf die ein Executable zu seiner Ausführung zugreifen möchte, führt.
            Anders als bei herkömlichen GOTs werden in diesen Objekten keine Offsets, sondern reine Zeiger gespeichert. Auch ausführbarer Code für Bibliotheksaufrufe befindet sich nicht in einer solchen GOT. 
            {gramm: Auf} Die "companion"-GOT kann in RISC-ViO immer über das Register <em>x3</em> (<em>gp</em>) zugegriffen werden. Es ist Aufgabe der Hardware oder des Betriebssystems dafür zu sorgen, dass das gp-Register immer
            auf das dem Executable zugehörigen GOT-Objekt verweist. 
        </i></p>
    <h2><a id="static">Making library calls</a></h2>
        <p><i>Um nun einen Bibliotheksaufruf auszuführen wird zuerst die Adresse der Bibliotheksfunktion aus der GOT mittels eines normalen Ladebefehls geladen und dann mit einem jalr and diese Adresse gesprungen.
            Um dem Linker mitzuteilen, dass für dieses Sprungziel ein GOT-Eintrag angelegt werden soll, wurde ein neuer Assembler Modifier eingeführt: %got_off(symbol). Dieser Modifier wird vom Linker ersetzt durch den Offset
            in der GOT der Executable an dem das symbol zu finden ist. Zu diesem Zweck wurde auch ein neuer Relocation/Dynsym-Typ eingeführt, um in ELF-Files zu markieren dass an einer bestimmten Stelle der load-offset noch
            ersetzt werden muss, mit dem endgültigen Offset der Adresse in der GOT, ähnlich wie es auch bei den Assembler Modifiern %hi, %lo, usw. gehandhabt wird.
            Ein<br>call symbol<br>wird also nun ersetzt durch eine<br>lw t1, %got_off(symbol)(gp)<br>jalr ra, 0(t1)<br>Abfolge.
        </i></p>
    <h2><a id="static">Accessing static objects</a></h2>
        <p><i>Nach dem selben Prinzip werden auch Zugriffe auf statische Objekte gehandhabt. Über den %got_off modifier wird der Linker angewiesen, den Zeiger auf das Objekt in der GOT vorzuhalten und den Zugriff
            auf das Objekt zur Load-Time aufzulösen. Die statischen Objekte werden auch schon in herkömmlichen ELF-Files markiert, sodass der Lader in ViO mit einem normalen ALC Befehl das statische Objekt anlegen,
            evtl. befüllen und den Zeiger auf dieses Objekt in der GOT hinterlegen kann.
        </i></p>
    </section>


    
    <section>
    <h1><a id="exceptions">Exceptions</a></h1>
        <h2><a id="gen">Enforcing correct program behaviour</a></h2>
            <p>
                To enforce the pointer based memory access scheme, the processor will raise a <em>IncompatibleTypeException</em> when a program tries to use an address value to access memory. 
                Since the object length is known on ISA level, the processor is able to raise a <em>IndexOutBoundsException</em> when an out of bound load or store instruction is executed.
                In case of such an exception, <em>xtval</em> will contain the base pointer as well as the index which was beyond the object bounds.
                The processor is also able to detect whether the destination object is compatible with the current access type by checking the permission tags of the object. 
                In consequence, <em>LoadAccessFault</em>, <em>StoreAccessFault</em> or <em>IncompatibleTypeException</em> are raised when the corresponding flag is not set as per <a href="#objs_ords">ordinary objects</a>. 
                <em>LoadAccessFault</em>s are triggered when the 'read' flag is cleared while <em>StoreAccessFault</em> is raised in case of a store access to a object with cleared 'write' flag.
                Trying to store pointers to a data only object marked by a set 'data only' flag will lead to a <em>IncompatibleTypeException</em>. 
                The same exception is triggered when trying to jump to a regular object using <em>jalr</em> or when trying to do an arithmetic or logical operation on two pointers which are not both of memory type.
            </p>
            <p>
                Trying to access the register <em>gp</em> for anything other than as a access pointer in a memory instruction will lead to a <em>GPAccessException</em>.
            </p>
            <p>
                To inform the software that a access to a regular or executable object would violate its bounds, a <em>JumpIndexOutBoundsException</em> is raised in case of an executable object or a <em>IndexOutBoundsException</em> in case of a regular object.
                Should the heap onto which new objects are allocated on reach the end of its capacity, a <em>HeapOverflowException</em> is raised.
            </p>
            <p>
                In the context of frame objects, a total of three exceptions are added to the exception list.
                A <em>StateException</em> catches access to foreign frame objects as described in <a href="#frame_ownership">frame ownership</a>.
                Even when a frame object is owned by the currently executed function, there are still two more exceptions possible: <em>ForbiddenDstException</em> is raised when trying anthing else than <em>ra</em> or <em>gp</em> into their slots.
                <em>ForbiddenSrcException</em> checks for using these slots as specified in case of load accesses.

            </p>
            <p>
                The <em>IncompatibleTypeException</em> is raised when a pointer is written to a I/O device using its corresponding pointer.
            </p>
        <h2><a id="gen">Exceptions in conjunction with CSR</a></h2>
            <p>Since RISC-ViO allows both pointers and values to be stored in the registers and also organizes code using objects, some CSR also need to be able to hold pointers.
                This is the case for <em>xtvec</em> and <em>xepc</em> due to executable objects and for <em>xtval</em> and <em>xscratch</em> due to pointers in general.
                To access the components of these registers, the <em>csrw</em> instruction may be used in conjunction with the <em>dtp</em>/<em>btd</em>/<em>itd</em> instructions.
                Apart from this slight modification as well as the expansion of available exceptions, exceptions and interrupts behave identical to the way they do in RISC-V.
            </p>
        <h2><a id="priv">Exception masking</a></h2>
            <p>
                The <a href="#t_csr">exception table</a> provides an overview of the exceptions corresponding to the protection schemes introduced by RISC-ViO.
                In order to allow higher privilege modes to gain the access required for system management, some exceptions are suppressed in certain privilege modes.
            </p>
        
    </section>

    <div style="margin-top: 3rem; margin-bottom: 3rem;">
        <div style="font-size: 9pt; text-align: center;">ISA</div>
        <hr>
        <div style="font-size: 9pt; text-align: center;">implementation</div>
    </div>


    <h1><a id="reg_fl">Values and pointers in the register file</a></h1>
    <section>
    <p>
        Every RISC-ViO architecture requires a register file which is able to satisfy the requirements given in the <a href="#base_spec">I'</a> chapter.
        Apart from these requirements, RISC-ViO does not specify how a register file of an implementation of this architecture has to look like.
        This leaves room for tailoring the implemented register file to the design constraints at hand. 
    </p>
    <p style="font-size: 9pt;">
        (Please note that in this specification, pointers are written in the form x.y where x is a pointers value (base address + tag) and y is the index of the pointer. To graphically set apart pointers from values, pointers are drawn in various shades of pink and purple.
        Values are not denoted in any special way in text form but drawn in light blue.)
    </p>
    </section>
    <h2><a id="fields">Fields</a></h2>
    <section>
        <p>The subarchitecture implementation offered here is meant only as an example implementation and is focused on higher performance while requiring more hardware resources. The register sections required by the RISC-ViO specification are denoted with 'ISA' while sections introduced by this particular implementation are denoted with 'IMP'. In this implementation, the 'IMP' sections are exclusively made up of object header metadata drawn in green.  </p>
        <figure style="display:flex; margin-bottom: 0.5rem">
            <div style="flex: 30%; margin-bottom: 0.5rem">
                <figcaption>An example implementation of a RISC-ViO register file</figcaption>
                <img src="svg/register_file.drawio.svg" id="register_file_svg" style="width: 100%;margin-bottom: 0.5rem">
            </div>
        </figure>
        <p>In the provided implementation, the hardware will update <em>gp</em> on every jump to another executanle object. In case of exceptions,interrupts and code object changes due to <em>sret/mret</em>, it is the duty of the system management software to update <em>gp</em> accordingly.</p>
    </section>
    <h2><a id="coloring">Colouring</a></h2>
    <section>
        <p>As described in the <a href="#frames">frames</a> chapter and as present in the requirements list in <a href="#base_spec">I'</a>, RISC-ViO calls for the ability to hold colour information for both the <em>ra</em> as well as the <em>sp</em> register. 
            The implementation presented here is able to satisfy this requirement using the fields as shown in the last section only. In this implementation, the colour 'black' is encoded as a cleared bit ('0') while 'white' corresponds to a bit which is set ('1'). 
            Since the smallest possible instruction size specified by RISC-V is 16 bits or two bytes, the lowest bit of the index of <em>ra</em> always has to be 0.
            This is why it is possible to encode the current colour of <em>ra</em> in this bit. For <em>sp</em>, the same is not true however since its index may be set to any value.
            The colour of <em>sp</em> is instead stored in the current frames header copy in the register file. More specifically, the colour-bit in this header is used for storing <em>sp</em>'s colour.
        </p>
    </section>
    <h2><a id="flgs_tgs">Flags and Tags</a></h2>
    <section>
        <p>In order to distinguish pointers from values, the provided implementation uses a tag bit for all registers which may hold both values or pointers. Values are tagged as '0' while pointers are identified by a '1' bit.
            Since on ISA level, RISC-ViO only distinguishes between regular an I/O pointers, only a single bit in the register file is required to keep those pointer types apart.
            This bit is interpreted as part of the pointer and is added to the right of the pointer base address or I/O device number for I/O pointers.
        </p>
    </section>


    <h1><a id="hard_obj">Objects in Memory</a></h1>
    <section style="display:flex">
        <div class="screen2_print1">
            <h2 style="text-align: center;"><a id="headers">Headers</a></h2>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                Headers mark the beginning of every Object. They hold all information about the object necessary to ensure proper handling of itself. Headers are always 16-Byte aligned.</p>
            <figure>
                <img src="svg/objektbaukasten/header.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>Header Bitmap on 32-Bit Architectures</figcaption>
            </figure>
            <table summary="Bit Values of Object Headers" style="width: 80%; margin-left: 10%; margin-right: 10%;">
                <thead>
                    <tr>
                        <th>Bits</th>
                        <th>Sym.</th>
                        <th>Details</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>31:30</td>
                        <td>gc</td>
                        <td>Bits reserved for garbage collection</td>
                    </tr>
                    <tr>
                        <td>29</td>
                        <td>r</td>
                        <td>Readable</td>
                    </tr>
                    <tr>
                        <td>28</td>
                        <td>w</td>
                        <td>Writable</td>
                    </tr>
                    <tr>
                        <td>27</td>
                        <td>d</td>
                        <td>Data-Only</td>
                    </tr>
                    <tr>
                        <td>26</td>
                        <td>s</td>
                        <td>Sanctuary</td>
                    </tr>
                    <tr>
                        <td><i>25:7</i></td>
                        <td><i>-</i></td>
                        <td><i>don't care</i></td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td>c</td>
                        <td>Color of Frame Objects.<br>See <a href="#frames">Frames Chapter</a></td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>f</td>
                        <td>Frame Object</td>
                    </tr>
                    <tr>
                        <td>4:0</td>
                        <td>-</td>
                        <td>Header Identifier</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>31:3</td>
                        <td>λ</td>
                        <td>Length of Object<br>(only bits (63|31):3)</td>
                    </tr>
                    <tr>
                        <td><i>1</i></td>
                        <td><i>-</i></td>
                        <td><i>don't care</i></td>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td>-</td>
                        <td>Data Identifier</td>
                    </tr>
                </tbody>
            </table>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                <i>On a 64-Bit Architecture the upper bits of the header bitmap are shifted upwards to 64-Bit boundaries.</i></p>

            <h2 style="text-align: center;"><a id="elements">Elements</a></h2>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                Elements of Objects are tagged by the lowest Bit(s) in a Chunk of Memory.
                On a 32-Bit Architecture this Chunk is 32 bits wide, on 64-Bit Architectures 64 bits.</p>
            <figure style="margin-top: 0; margin-bottom: 1em">
                <img src="svg/objektbaukasten/data.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>Word, Half and Byte locations in an ordinary object</figcaption>
            </figure>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                Data in Ordinary Objects is identified by the trailing <em>0</em>-Bit. If a Store is attempted, which would make the two uppermost bits of a chunk unequal (e.g. <em>bit-31 &ne; bit-30</em> on a 32-Bit Architecture)
                then the Data is stored to the current sanctuary Object instead and the corresponding displacement pointer will be stored to the address the original store was attempted to.</p>
            <figure style="margin-top: 0; margin-bottom: 1em">
                <img src="svg/objektbaukasten/disp_prim_ptr.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>Pointer to displaced data</figcaption>
            </figure>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                These Pointers are identified by trailing <em>01</em>-Bits.</p>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%; margin-top: 2em">
                Pointers to Objects are identified by trailing <em>0111</em>-Bits. They can be generated by allocation instructions and point to the head of ordinary, data-only and executable objects.</p>
            <figure style="margin-top: 0; margin-bottom: 1em">
                <img src="svg/objektbaukasten/pointer.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>Pointer to an Object</figcaption>
            </figure>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                If a store is attempted on a pointer that was modified by arithmetic instructions so that its index is unequal to zero, the pointer will be displaced into the current sanctuary object and only the displacement pointer
                is stored to the original address the store was attemped to.</p>
            <figure style="margin-top: 0; margin-bottom: 1em">
                <img src="svg/objektbaukasten/disp_ptr_ptr.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>Pointer to a displaced Pointer</figcaption>
            </figure>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                These Pointers are identified by trailing <em>011</em>-Bits.</p>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%; margin-top: 2em">
                Pointers to I/O-Capabilities are identified by the trailing <em>01111</em>-Bits. They hold a device-id which identify what I/O-Device is referenced.</p>
            <figure style="margin-top: 0; margin-bottom: 1em">
                <img src="svg/objektbaukasten/io_ptr.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>I/O-Pointer</figcaption>
            </figure>
        </div>
        <div class="screen2_print1">
            <h2 style="text-align: center;"><a id="ords">Ordinaries</a></h2>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                Ordinary Objects always start with a Header and can hold every element type defined.</p>
            <figure style="margin-top: 0;">
                <img src="svg/objektbaukasten/ordinary_object.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>Ordinary Object and its possible Elements</figcaption>
            </figure>
            
            <h2 style="text-align: center;"><a id="data-onlies">Data-Only Objects</a></h2>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                Data-Only Objects are identified by the data-only Bit in the Header. Data inside of these Objects is not tagged, so they make use of the whole 64|32 Bit per Element.
                Pointers are forbidden inside data-only Objects.</p>
            <figure style="margin-top: 0;">
                <img src="svg/objektbaukasten/data_only_object.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>Data-Only Object</figcaption>
            </figure>

            <h2 style="text-align: center;"><a id="execs">Executables</a></h2>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                Executables have only the data-only bit set in their header. This identifies them as a executable.<br>
                As part of their Header, Executables have the pointer to their companion GOT stored at the third (double-)word of the object. The start of Code is then referred as index 0 of the objuect.
                It is stored in the same fashion as in data-only so they can harvest the full 64|32 bit of a Element.</p>
            <figure style="margin-top: 0;">
                <img src="svg/objektbaukasten/executable_object.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>Executable Object</figcaption>
            </figure>

            <h2 style="text-align: center;"><a id="sancts">Sanctuaries</a></h2>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                Sanctuaries only have the Sanctuary Bit set in their header. They are used as memory space for displaced primitives and displaced pointers and cannot be referenced by ordinary pointers.<br>
                Displaced Pointers take two Element Slots, one for the base pointer and one for the index, thus are always aligned to 2-Element boundaries.
                The base pointer is stored as a ordinary pointer and the index as data-only primitive.<br>
                Displaced Primitives only take one Element Slot beeing the (Double-)Word that was displaced. These Types can be stored at any Element position inside the Sanctuary.</p>
            <figure style="margin-top: 0;">
                <img src="svg/objektbaukasten/data_only_object.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>Sanctuary Object</figcaption>
            </figure>
        </div>
    </section>

    <h1><a id="ptr_addr">Pointer and address generation</a></h1>
        <p>The provided implementation example of the RISC-ViO architecture by using the object structures outlined above implies new requirements for a processor pipeline supporting this implementation.
            In the next sections, a possible subarchitecture meeting those requirements shall be described. </p>
    <h2><a id="alcs">Allocations</a></h2>
    <section>
        <p>In the presented implementation, all members of the alc instruction family place both regular data objects as well as frames objects on the heap. 
            There the objects lie in allocation order until a garbage collection cycle occurs. The CSR <em>malc</em> is used to keep track of the heap fill level and heap limit. <em>malc.ix</em> keeps track of to the newest objects start address while <em>malc.ptr</em> contains the lower limit of the heap in form of an address. 
            In the process of such a cycle, objects may be moved or overwritten in case of not being required anymore.
        </p>
        <p>
            The allocation process starts by calculating the address of the address of the new object header. 
            This is given by rounding down the value given by the expression
        </p>
        <div class="equation">
            <math>
                <mtable>
                    <mtr>
                        <mtd>
                            <mi>malc.ix</mi>
                            <mo>-</mo>
                            <mo>(</mo>
                            <mi>8</mi>
                            <mo>+</mo>
                            <mi>size</mi>
                            <mo>)</mo>
                        </mtd>
                    </mtr>
                </mtable>
            </math>
        </div>
        <p>
            down to next number divisible by 16. If this value is larger than malc.ptr the new object fits inside the heap and malc.ix is updated to this value.
            In this case, a pointer tag is added to the newly calculated address and the resulting pointer value is written to the target register.
            The initial index is set to zero. 
        </p>
        <p>
            To commit the header of this new object to memory, the so-called attribute cache is used. 
            This cache is located in the attribute stage located behind the memory stage and is mainly used to both retrieve and load object attributes.
            In case of values with bit 31 set or pointers with non-zero index this cache is also used to both store and retrieve these types of data to and from memory.
        </p>
        <figure>
            <figcaption>Heap limits and growth.</figcaption>
            <div style="display: flex; margin-top: 14pt; margin-bottom: 28pt; height: 25rem">
                <img src="svg/vio_heap_growth.drawio.svg" id="svg1" style="flex: 50%; margin-right: 10pt;">
                <img src="svg/vio_heap_overflow.drawio.svg" id="svg1" style="flex: 50%; margin-right: 10pt;">
            </div>
            <div style="display: flex;">
                <p style="flex: 50%; ">a) Regular heap growth </p>
                <p style="flex: 50%; ">b) Heap overflow</p>
            </div>
        </figure>
        <p>
            The given implementation uses sanctuary objects to cope with the requirement to distinguish between pointers and values in memory.
            Any time a value with the highest bit set or a pointer with a non-zero index is stored, a slot of corresponding size and alignment in the current sanctuary object is used.
            For values this alignment and size is 4 bytes while for pointers with index it is 8 bytes. 
            The sample implementation has the sanctuary index point to the last used slot in the sanctuary object and decrements this index on every sanctuary slot allocation.
        </p>
        <p>
            When the current sanctuary object is full, which is signified by the sanctuary index being zero, while a new sanctuary slot is required, a new sanctuary object is allocated.
            For this, the current allocation address is decremented according to the implementation-dependant sanctuary object size and the sanctuary object address is set to this value.
            Also, the sanctuary slot index is set to highest possible value for the new sanctuary object to be once again be filled from the top to the bottom.
            In order to ensure the garbage collector being aware of this object, the attribute cache in the attribute stage also writes a header stub to the address at which the sanctuary object lies.
            In the flags field of this header, the sanctuary bit marks this object as a sanctuary object.
        </p>
        <p>
            In order to allow a system management software to control the allocation of sanctuary objects, a new CSR called <em>msad</em> is introduced. The pointer contained in this CSR has the current allocation index in the sanctuary object as its pointer field while the address of the current sanctuary object is located in the index field of this CSR.
            The CSR index of the <em>msad</em> CSR can be extracted from the <a href="#t_csr">CSR table</a>.
        </p>
    </section>
    <h2><a id="load_store">Loading and storing a pointer</a></h2>
    <section>
        <p>As the subarchitectural implementation requires some flag bit from the object header as well as its length or lambda field, those fields also have to be retrieved from memory when loading a pointer. 
            For this, the example subarchitectural implementation uses an additional pipeline stage called the attribute stage which is located behind the memory stage in the processor pipeline.<br>
            The <a href="#t_instr_in_pipe">instruction behaviuor table</a> shows how this stage interacts with the stages that come before it, this section looks at this interaction in further detail.
            After the memory stage has loaded a pointer, the attribute stage then loads the header being pointed to by the pointer base address. This header along with the actual pointer value is then handed over to the write-back stage which writes those fields into the register file.
            In the given subarchitectural implementation, the attribute stage is used to accomplish additional tasks like loading full XLEN wide data, meaning data with bits 30 and 31 being unequal, or a pointer with non-zero index from an object. 
            For the task of loading full XLEN wide data, it is the task of the attribute stage to load the actual data from memory instead of the memory stage. 
            This is necessary since the memory stage has to determine where this data is located in memory first by loading the according displacement pointer.
            For pointers with a non-zero index, the attribute stage also has to become active. Since requiring both the loading of a pointers index as well as the header of the object pointed to, this operation takes two clock cycles however and therefore necessitates stalling the remaining pipeline until both operations have been completed.
            In this situation, the attributes stage will load the pointer index before loading the object header and combining the loaded fields with the pointer value loaded by the memory stage and passing the combined register file entry to the writeback stage.
        </p>
        <p>
            The process of storing register contents is analogous to the process of loading values as well as pointers regarding the fundamental tasks accomplished by the memory and attribute stages. The only difference other than those stages storing instead of loading is that the attribute stage might need to allocate a new 'Sanctuary object' to store XLEN wide values or pointers with non-zero index into.
            This task is completed by a special subunit, which avoids the attribute stage having to stall the remaining pipeline when storing a XLEN value or pointer with non-zero index while also needing a new Sanctuary Object to be allocated.
        </p>
    </section>

    <h2><a id="bounds">Bounds and Flag checks</a></h2>
    <section>
        <p>As the outlined subarchitecture keeps the length of the corresponding object for each pointer in the register file, it is possible to check for an out of bound access as soon as the actual access index is available. 
            This can be the case as early as in the execute stage, which allows for early raising of <em>IndexOutBoundsException</em>s. 
            Since an objects flags which signify it as being readable, writeable and data only are also available as soon as the pointer to this object is available in the processor, the conditions for <em>LoadAccessFault</em> and <em>StoreAccessFault</em> exceptions can also be tested for just as early.</p>
    </section>

    <h1><a id="tables">Tables</a></h1>
    
    
    <section>
    <h2><a id="t_inst">Instructions (zhm extension)</a></h2>
        <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center">
            <colgroup>
                <col width="20%"/>
                <col width="13%"/>
                <col width="14%"/>
                <col width="8%"/>
                <col width="14%"/>
                <col width="20%"/>
            </colgroup>
            <thead>
                <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">31</div><div style="float: right">25</div>
                </th>
                <th style="border-style:solid; border-width: 0px;">
                    <div style="float: left">24</div><div style="float: right">20</div>
                </th>
                <th style="border-style:solid; border-width: 0px;">
                    <div style="float: left">19</div><div style="float: right">15</div>
                </th>
                <th style="border-style:solid; border-width: 0px;">
                    <div style="float: left">14</div><div style="float: right">12</div>
                </th>
                <th style="border-style:solid; border-width: 0px;">
                    <div style="float: left">11</div><div style="float: right">7</div>
                </th>
                <th style="border-style:solid; border-width: 0px;">
                    <div style="float: left">6</div><div style="float: right">0</div>
                </th>
                <th style="border-style:solid; border-width: 0px;">
                    Instruction
                </th>
            </thead>
            <tbody>
                <tr  style="float: center">
                    <td>0000000</td><td>rs1(src)</td><td>00010</td><td>000</td><td>rd(dst)</td><td>0001011</td><td>alc</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td colspan="2">imm[13:2]</td><td>00010</td><td>010</td><td>rd(dst)</td><td>0001011</td><td>alci</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td>0000000</td><td>rs1(src)</td><td>00010</td><td>001</td><td>rd(dst)</td><td>0001011</td><td>alcd</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td colspan="2">imm[13:2]</td><td>00010</td><td>011</td><td>rd(dst)</td><td>0001011</td><td>alcid</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td>0000000</td><td>0000</td><td>rs1(src)</td><td>100</td><td>rd(dst)</td><td>0001011</td><td>qsz</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td>0111111</td><td>rs2(ix)</td><td>rs1(ptr)</td><td>000</td><td>rd(dst)</td><td>1001001</td><td>dtp</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td>1011111</td><td>00000</td><td>rs1(ptr)</td><td>000</td><td>rd(dst)</td><td>1001001</td><td>itd</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td>1101111</td><td>00000</td><td>rs1(ptr)</td><td>000</td><td>rd(dst)</td><td>1001001</td><td>btd</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td>1110111</td><td>00000</td><td>rs1(src)</td><td>000</td><td>rd(dst)</td><td>1001001</td><td>lt</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td>1111011</td><td>rs2(sd)</td><td>rs1(ptr)</td><td>000</td><td>00000</td><td>0001011</td><td>st</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td>1111101</td><td>00000</td><td>rs1(ptr)</td><td>000</td><td>00000</td><td>0001011</td><td>clr</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td>1111110</td><td>00000</td><td>rs1(ptr)</td><td>000</td><td>rd(tag)</td><td>0001011</td><td>sep</td>
                </tr>
            </tbody>
        </table>
    </section>

    <h2 class="page-break-before"><a id="t_op">Object and Pointer Types</a></h2>
    <section>
        <figure style="display:flex">
            <div style="flex: 50%;">
                <p style="font-size: 16pt; font-style: italic; text-indent:0;">Header</p>
                <img src="svg/objektbaukasten/header.svg" id="header_table_svg" style="width: 60%;">
                <p style="font-size: 16pt; font-style: italic; text-indent:0; margin-top: 1.5rem;">Data</p>
                <img src="svg/objektbaukasten/data.svg" id="header_table_svg" style="width: 60%;">
                <p style="font-size: 16pt; font-style: italic; text-indent:0; margin-top: 1.5rem;">Displacement Pointer (Primitive)</p>
                <img src="svg/objektbaukasten/disp_prim_ptr.svg" id="header_table_svg" style="width: 60%;">
                <p style="font-size: 16pt; font-style: italic; text-indent:0; margin-top: 1.5rem;">Displacement Pointer (Pointer)</p>
                <img src="svg/objektbaukasten/disp_ptr_ptr.svg" id="header_table_svg" style="width: 60%;">
                <p style="font-size: 16pt; font-style: italic; text-indent:0; margin-top: 1.5rem;">Ordinary Pointer</p>
                <img src="svg/objektbaukasten/pointer.svg" id="header_table_svg" style="width: 60%;">
                <p style="font-size: 16pt; font-style: italic; text-indent:0; margin-top: 1.5rem;">I/O-Pointer</p>
                <img src="svg/objektbaukasten/io_ptr.svg" id="header_table_svg" style="width: 60%;">
            </div>
            <div style="flex: 50%;">
                <p style="font-size: 16pt; font-style: italic; text-indent:0;">Ordinary Object</p>
                <img src="svg/objektbaukasten/ordinary_object.svg" id="header_table_svg" style="width: 60%;">
                <p style="font-size: 16pt; font-style: italic; text-indent:0; margin-top: 1.5rem;">Executable Object</p>
                <img src="svg/objektbaukasten/executable_object.svg" id="header_table_svg" style="width: 60%;">
                <p style="font-size: 16pt; font-style: italic; text-indent:0; margin-top: 1.5rem;">Data-Only Object</p>
                <img src="svg/objektbaukasten/data_only_object.svg" id="header_table_svg" style="width: 60%;">
            </div>
        </figure>
    </section>
    <h2><a id="t_exc">Exceptions</a></h2>
    <section>
        <table summary="Exceptions and their numbers for privilege modes" style="margin-bottom: 0;">
            <thead>
            <tr>
                <th rowspan="2">
                    <em>xcause index</em>
                </th>
                <th rowspan="2">
                    <em>Name</em>
                </th>
                <th colspan="3">
                    <em>may be raised in privilege mode</em>
                </th>
            </tr>
            <tr>
                <th><em>user</em></th>
                <th><em>supervisor</em></th>
                <th><em>machine</em></th>
            </tr>
            <tr>
                <th>16</th>
                <th>JumpIndexOutBoundsException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>17</th>
                <th>GPAccessException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>18</th>
                <th>IndexOutBoundsException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>19</th>
                <th>HeapOverflowException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>20</th>
                <th>StateException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>21</th>
                <th>ForbiddenSrcException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>22</th>
                <th>ForbiddenDstException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>23</th>
                <th>IncompatibleTypeException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
        </thead>
        <tbody>

        </tbody>
        </table>
    </section>
    <h2><a id="t_csr">CSRs</a></h2>
    <section>
        <table summary="CSR added by zhm extension" style="margin-bottom: 0;">
            <thead>
            <tr>
                <th rowspan="2">
                    <em>CSR index</em>
                </th>
                <th rowspan="2">
                    <em>Name</em>
                </th>
                <th colspan="2">
                    <em>subfields</em>
                </th>
            </tr>
            <tr>
                <th><em>ptr</em></th>
                <th><em>index</em></th>
            </tr>
            <tr>
                <th>0xBC0</th>
                <th>MALC</th>
                <th>current allocation address</th>
                <th>heap end adress</th>
            </tr>
            <tr>
                <th>0xBC1</th>
                <th>MSAD</th>
                <th>current index in sanctuary object</th>
                <th>address of current sanctuary object</th>
            </tr>
           
        </thead>
        <tbody>

        </tbody>
        </table>
    </section>
    <h2 class="page-break-before"><a id="t_heap">Example of a Heap</a></h2>
    <figure class="page-break-after">
        <img src="svg/pretty_heap.svg" id="heap">
    </figure>

    <h2 class="page-break-before"><a id="t_instr_in_pipe">Instructions in a sample Pipeline</a></h2>
    <p>
        This table shows how a pipeline backend implementing the RISC-ViO architecture may look like.
        For this, the fields of the content to be written to a register is shown in the EXecute, MEmory and the new ATtribute stage.
        Also, for each stage the units which are active in this stage for the given instruction are listed. A result field value of 'pass' means that this pipeline stage will only pass along the value of rd from the prior stage while '~' means that rd is invalid and this instruction will not write anything to the register file.
    </p>
    <section>
        <table border="0" cellspacing="0" cellpadding="0" class="table-ta1" style="text-align:left">
            <colgroup>
                <col width="172"/>
                <col width="40"/>
                <col width="40"/>
                <col width="40"/>
                <col width="50"/>
                <col width="300"/>
                <col width="250"/>
                <col width="200"/>
                <col width="250"/>
                <col width="200"/>
                <col width="200"/>
                <col width="150"/>
                <col width="94"/>
            </colgroup>
            <tr class="row-ro1">
                <td colspan="5" style="text-align:left " ></td>

                
                <td colspan="8" style="text-align:center; " >
                    <p>Fields and Actions by Stages</p>
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " ></td>

                <td colspan="3" style="text-align:center; " >
                    register file indeces
                </td>
                <td style="text-align:left; " ></td>
                
                <td colspan="2" style="text-align:center; " >
                    EX
                </td>
                <td colspan="2" style="text-align:center; " >
                    ME
                </td>
                <td colspan="2" style="text-align:center; " >
                    AT first pass
                </td>
                <td colspan="2" style="text-align:center; " >
                    AT second pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    Instruction
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm
                </td>
                
                <td style="text-align:center; " >
                    Actions
                </td>
                <td style="text-align:center; " >
                    Results
                </td>
                <td style="text-align:center; " >
                    Actions
                </td>
                <td style="text-align:center; " >
                    Results
                </td>
                <td style="text-align:center; " >
                    Actions
                </td>
                <td style="text-align:center; " >
                    Results
                </td>
                <td style="text-align:center; " >
                    Actions
                </td>
                <td style="text-align:center; " >
                    Results
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    lui
                </td>

                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm20
                </td>
                
                <td style="text-align:left; " >
                    ALU: add
                </td>
                <td style="text-align:left; " >
                    rd: (T:d, P:0, I:val, L:0, H:0)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    auipc
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    ALU: add
                </td>
                <td style="text-align:left; " >
                    rd: (T:p, P:pc.ptr, I:val, L:pc.l, H:pc.hdr)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    jal
                </td>

                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm20
                </td>
                
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    rd: (T:p, P:pc.ptr, I:pc.ix, L:pc.l, H:pc.hdr)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    jalr step 1
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    gp
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: load
                </td>
                <td style="text-align:left; " >
                    rd:(T:p, P:val, I:0, H:hdr, L:l)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    jalr step 2
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd<sup>2</sup> 
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    DBU: b_tgt
                </td>
                <td style="text-align:left; " >
                    rd: (T:p, P:pc.ptr, I:pc.ix, L:pc.l, H:pc.hdr)<sup>2</sup>
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    bcc
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    disp
                </td>
                
                <td style="text-align:left; " >
                    ALU: comp DBU: (b_tgt)
                </td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    arithi (any data op)
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    ALU: op=imm12 X rs1
                </td>
                <td style="text-align:left; " >
                    rd: (T:d, P:rs1.P, I:val, L:rs1.L, H:rs1.H)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    arithr (any data op)
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    ALU: op=rs2 X rs1
                </td>
                <td style="text-align:left; " >
                    rd: (T:d, P:val, I:val, L:val, H:val)<sup>1</sup>
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    lb/lbu/lh/lhu
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: lb/lbu/lh/lhu
                </td>
                <td style="text-align:left; " >
                    rd:(T:d, P:0, I:val, H:0, L:0)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    sb/sh<sup>3</sup>
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: sb/sh
                </td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    sb/sh<sup>4</sup>
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: sw DU: alc_data
                </td>
                <td style="text-align:left; " >
                    caddr, six (sptr, aaddr)
                </td>
                <td style="text-align:left; " >
                    AC: sw (SA: alloc)
                </td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    lw (value<sup>3</sup>)
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: load
                </td>
                <td style="text-align:left; " >
                    rd:(T:d, P:0, I: val, H:0, L:0)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    lw (value<sup>4</sup>)
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: load
                </td>
                <td style="text-align:left; " >
                    caddr
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    rd: (T:d, P:0, I:val, L:0, H:0)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    lw pointer<sup>5</sup>
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: load
                </td>
                <td style="text-align:left; " >
                    rd:(T:p, P:val, I:0, H:hdr, L:l)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    lw pointer<sup>6</sup>
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: load
                </td>
                <td style="text-align:left; " >
                    rd:(T:p, P:val)
                </td>
                <td style="text-align:left; " >
                    AC: lw
                </td>
                <td style="text-align:left; " >
                    rd: ix_val
                </td>
                <td style="text-align:left; " >
                    AC: lw
                </td>
                <td style="text-align:left; " >
                    rd: l, hdr
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    sw (value<sup>3</sup>)
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: sw
                </td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    sw (value<sup>4</sup>)
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: sw, DU: alc_sadp
                </td>
                <td style="text-align:left; " >
                    caddr, six (sptr, aaddr)
                </td>
                <td style="text-align:left; " >
                    AC: sw (SA: alloc)
                </td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    sw pointer<sup>5</sup>
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: sw
                </td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    sw pointer<sup>6</sup>
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: sw DU: alc_sadd
                </td>
                <td style="text-align:left; " >
                    caddr, six (sptr, aaddr)
                </td>
                <td style="text-align:left; " >
                    AC: sw (SA: alloc)
                </td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    alc
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    rd: (T:p, P:val, I:0, L: val, H:val), aaddr,caddr
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " >
                    AC: sw [object header]
                </td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    alci
                </td>

                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    rd: (T:p, P:val, I:0, L: val, H:val), aaddr,caddr
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " >
                    AC: sw [object header]
                </td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    alc.d
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    rd: (T:p, P:val, I:0, L: val, H:val), aaddr,caddr
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " >
                    AC: sw [object header]
                </td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    alci.d
                </td>

                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    rd: (T:p, P:val, I:0, L: val, H:val), aaddr,caddr
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " >
                    AC: sw [object header]
                </td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    qsz
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    PGU: rd
                </td>
                <td style="text-align:left; " >
                    rd: (T:d, P:0, I:val, L:0, H:0)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    dtp
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    rd: (T:p, P:val, I:val), caddr
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " >
                    AC: lw [object header]
                </td>
                <td style="text-align:left; " >
                    rd: (L:val, H:val)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    btd
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    PGU: rd
                </td>
                <td style="text-align:left; " >
                    rd: (T:d, P:0, I:val, L:0, H:0)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    itd
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    PGU: rd
                </td>
                <td style="text-align:left; " >
                    rd: (T:d, P:0, I:val, L:0, H:0)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    lw.x
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: load
                </td>
                <td style="text-align:left; " >
                    rd:(T:d, P:0, I:val, H:0, L:0)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    sw.x
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: sw
                </td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                
            </tr>
        </table>
        <p>
            Abbreviations used in the table:
            <table style="text-align:left; border-width: 0;">
            <td style="text-align:left; align:left; border-width: 0;" valign="top">
                <ul style="text-align:left; align:left">
                    <li>daddr: data cache address</li>
                    <li>aaddr: attribute cache address</li>
                    <li>caddr: malc current address</li>
                    <li>six: sanctuary slot index</li>
                    <li>sptr: sanctuary object pointer</li>
                </ul>
            </td>
            <td style="text-align:left; align:left; border-width: 0;" valign="top">
                <ul style="text-align:left; align:left">
                    <li>T: tag (d=data, p=pointer)</li>
                    <li>P: pointer value</li>
                    <li>I: pointer index or data value</li>
                    <li>L: object length</li>
                    <li>H: object header</li>
                </ul>
            </td>
            <td style="text-align:left; align:left; border-width: 0;" valign="top">
                <ul style="text-align:left; align:left">
                    <li>DC: data cache</li>
                    <li>AC: attribute cache</li>
                    <li>AGU: address generation unit</li>
                    <li>ALU: arithmetic logc unit</li>
                    <li>DBU: dynamic branch unit</li>
                    <li>DU: displacement unit (manages displacement to sanctuary objects)</li>
                    <li>SA: sanctuary allocator</li>
                </ul>
            </td>
            </table>
            *1: The values of P, L and H are dependent on both the values of rs1, rs2 as well as the given operation, following the rule outlined in the <a href="#riscv_i_tick">RISC-V I vs I'</a> chapter.<br>
            *2: For the ret variant of jalr, the target index of rd used for the writeback into the register file is ra while the target value is only the color bit in the index field with everything else being zero.<br>
            *3: For bit 31 &equals; bit 30<br>
            *4: For bit 31 &ne; bit 30<br>
            *5: For index &equals; 0<br>
            *6: For index &ne; 0
        </p>
    </section>



    
    <h1><a id="chap_refs">References</a></h1>
    <div class="references">
        <cite id="meyer_orisc">M.Meyer: "A Novel Processor Architecture with Exact Tag-Free Pointers" in Proceedings of the 2nd Workshop on Application Specific Processors., 2003.</cite>
        <cite id="llvm_gep">https://llvm.org/docs/LangRef.html#getelementptr-instruction, Last accessed 09.03.2025</cite>
    </div>

    <h1><a id="appendix">Appendix</a></h1>
    <h2><a id="boot">Boot Process</a></h2>
    <section>
        <p>
            After system reset, all registers are initialised with the value 0. Also, both <em>malc</em> and <em>msad</em> contain the value 0x0.0x0.
            The subarchitectural registers that contain the current executable object length and index also contain the value 0.
            The executable object initially executed is 0x7, so its header should be located at address zero and instructions should start at address 0xC. 
            To set up this register as well as <em>gp</em>, a system software should start with the following instruction sequence:
        </p>

        <code><br>
            0x7.0x0:  li      t0, 0b111 # create pointer to codeobject at address zero<br>
            0x7.0x4:  dtp     t0, t0, zero # turn the value into a pointer <br>
            0x7.0x8:  jalr    zero, t0, 12  # jump in there (should jump to the instruction just after this jalr)<br>
        </code>

        <p>
            After this, it is recommended to set both <em>malc</em> as well as <em>msad</em> to reasonable values using the csrw instruction.
            Since the processor starts up in the irregular state, this should be followed by an <em>alc</em> or <em>alci</em> instruction to get into regular state and be able to call functions.
        </p>
    </section>
    <h2><a id="implemenation_notes_chap">Implementation notes</a></h2>
    <p>
        The provided behaviour of the example of an RISC-ViO implementation can be further specified. This list provides a incomplete list of recommendations for such an implementation:
        <ol>
            <li>The dtp instruction should only load the header of a pointer if a valid pointer is specified via the rs1 register. Otherwise, the header and length fields in the pipeline should be set to 0.</li>

          </ol> 
    </p>
    <h2><a id="abbrevs_gloss">Glossary and abbreviations</a></h2>
    <ol>
        <li>XLEN - base integer ISA width (i.e. 32 for RV32)</li>
        <li>index - object field offset contained in a pointer</li>
        <li>offset - object fieöd offset being part of an instruction </li>
        <li>tag - bits making up a type information</li>
        <li>flag - a bit for a singular permission</li>
    </ol>
</body>

<script>
    var h1Toc = document.getElementById('toc'); 
    var headerList = document.querySelectorAll("h1, h2");

    var lastWasH2 = false;
    var toc = h1Toc;
    var h1Numbering = 0;
    var h2Numbering = 0;
    for (var i = 0; i < headerList.length; i++) {
        var header = headerList[i];
        if (header.childNodes.length == 0 || header.childNodes[0].nodeName != "A")
            continue;

        if (h2Numbering == 0 && header.nodeName == "H2"){
            const h2Toc = document.createElement("ul");
            h2Toc.style.paddingInlineStart = "28pt";
            h2Toc.style.listStyleType = "none";
            h2Toc.style.marginLeft = 0;
            h1Toc.appendChild(h2Toc);
            toc = h2Toc;
        } else if (h2Numbering > 0 && header.nodeName == "H1"){
            toc = h1Toc;
            h2Numbering = 0;
        }

        if (header.nodeName == "H1")
            h1Numbering++;
        
        if (header.nodeName == "H2")
            h2Numbering++;

        const li = document.createElement("li");
        li.className = "toc";
        if (h2Numbering == 0){
            li.style.fontSize = "14pt";
            li.style.fontWeight = "bold";
            li.appendChild(document.createTextNode(h1Numbering + ". "));
        } else {
            li.style.fontSize = "12pt";
            li.style.fontWeight = "normal";
            //li.appendChild(document.createTextNode(h1Numbering + "." + h2Numbering + ". "));
        }
        const link = header.childNodes[0].cloneNode(true);
        link.setAttribute("href", "#" + link.getAttribute("id"));
        link.setAttribute("class", "sl");
        link.setAttribute("id", null);
        li.appendChild(link);
        toc.appendChild(li);
    }
</script>
</html>