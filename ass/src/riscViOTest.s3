.globl core.start


@core>
start
init
private
start:      la      x3, @core
            ccp     x3, x3
            jalr    ra, @core.init(x3)
            nop
            nop

init:     
            li      frame, 0x805
            la      t0, @core.exc_handel
            csrw    mtvec, t0

            li      t1, 0x01020304
            li      t2, 0x8005
            li      t3, 0x86

            push    1,7
            sp      ra, 0(frame)
            sp      x3, 0(frame)
            sw      t1, 0(frame)
            sh      t2, 4(frame)
            sb      t3, 6(frame)

            lbu     a5, 6(frame)
            lb      a4, 6(frame)
            lhu     a3, 4(frame)
            lh      a2, 4(frame)
            lw      a1, 0(frame)
            lp      a0, 0(frame)
            lp      ra, 0(frame)



            # Device 1
            li      t1, 1
            # 3 Registers, register capability
            li      t2, 3 * 2 + 0
            ciop    s9, t1, t2
            
            mv      a1, s9
            la      a0, hello_world_str
            #TODO: find a nicer way to do this
            addi    a0, a0, -8 
            ccp     a0, a0
            
            jal     out_str

          
            nop
            nop
            ebreak


            push    1,0
            sp      ra, 0(frame)

            la      a0, @hdmi
            ccp     a0, a0

            la      s0, @usb
            ccp     s0, s0
            mv      s1, s0
            sp      s1, 0(frame)

            jalr    ra, @usb.af(s0)

            lp      s0, 0(frame)
            jalr    ra, @usb.b(s0)

            ebreak

# output string in object a0 via io obj in a1
out_str:    qdtb    t0, a0
            li      t1, 0
.outloop:   lbu.r    t2, t1(a0)
            #NOTE: change the index back to 0 for output 
            sb      t2, 2(a1)
            addi    t1, t1, 1
            bne     t1, t0, .outloop
            ret


exc_handel:
            nop
            nop
            nop
            nop
            nop
            nop 
            nop
            nop
            mret
            # test instr abort
            addi    t0, t0, -5
            addi    t1, t1, -9


@usb>
af
b
private

af:         addi    t0, t1,2
            addi    t3, t4,5
            ret                 #standard risc-v pseudo-instruction for jalr zero, 0(ra)

b:          push    0,0
            sp      ra, 0(frame)
            jal     c
            lp      ra, 0(frame)
            pop
            ret                 #standard risc-v pseudo-instruction for jr zero, 0(ra)

c:          push    0,0
            sp      ra, 0(frame)
            jalr    ra, @hdmi.s(a0)
            lp      ra, 0(frame)
            pop
            ret                 #standard risc-v pseudo-instruction for jr zero, 0(ra)


hello_world_str: object
            .ascii "Hello from RiscViO!\n"


@hdmi>
s
private

s:          addi    t0, t1,2
            addi    t3, t4,5
            ret                 #standard risc-v pseudo-instruction for jr zero, 0(ra)


