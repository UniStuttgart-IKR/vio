--
-- VHDL Architecture riscvio_lib.riscvio.struct
--
-- Created:
--          by - surfer.UNKNOWN (SURFER-A0000001)
--          at - 12:12:46 05.05.2024
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2021.1 Built on 14 Jan 2021 at 15:11:42
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
LIBRARY riscvio_lib;
USE riscvio_lib.isa.all;


ARCHITECTURE struct OF riscvio IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL alu_out        : dword_T;
   SIGNAL b              : dword_T;
   SIGNAL current_pc_d   : dword_T;
   SIGNAL dc_alu_mode    : alu_mode_T;
   SIGNAL dc_ctrl        : ctrl_signals_T;
   SIGNAL dc_imm         : imm_12_bit_T;
   SIGNAL dc_reg_a_data  : dword_T;
   SIGNAL dc_reg_b_data  : dword_T;
   SIGNAL dc_use_imm     : boolean;
   SIGNAL ex_alu_out     : dword_T;
   SIGNAL ex_ctrl        : ctrl_signals_T;
   SIGNAL falsesig       : boolean;
   SIGNAL if_ctrl        : ctrl_signals_T;
   SIGNAL if_instr       : word_T;
   SIGNAL if_instr_d     : word_T;
   SIGNAL incremented_pc : dword_T;
   SIGNAL me_alu_out     : dword_T;
   SIGNAL me_ctrl        : ctrl_signals_T;
   SIGNAL pc_current_pc  : dword_T;
   SIGNAL reg_a          : register_T;
   SIGNAL reg_b          : register_T;
   SIGNAL reg_c          : register_T;
   SIGNAL write_index    : register_index_T;
   SIGNAL write_reg      : register_T;
   SIGNAL write_reg_en   : boolean;
   SIGNAL zeroindex      : register_index_T;


   -- Component Declarations
   COMPONENT alu
   PORT (
      a       : IN     dword_T ;
      b       : IN     dword_T ;
      mode    : IN     alu_mode_T ;
      alu_out : OUT    dword_T ;
      flags   : OUT    alu_flags_T 
   );
   END COMPONENT;
   COMPONENT alu_input_mux
   PORT (
      imm      : IN     imm_12_bit_T;
      reg_data : IN     dword_T;
      use_imm  : IN     boolean;
      b        : OUT    dword_T
   );
   END COMPONENT;
   COMPONENT at_reg
   PORT (
      clk          : IN     std_logic;
      me_alu_out   : IN     dword_T;
      me_ctrl      : IN     ctrl_signals_T;
      res_n        : IN     std_logic;
      write_index  : OUT    register_index_T;
      write_reg    : OUT    register_T;
      write_reg_en : OUT    boolean
   );
   END COMPONENT;
   COMPONENT dc_reg
   PORT (
      clk           : IN     std_logic ;
      if_ctrl       : IN     ctrl_signals_T ;
      reg_a         : IN     register_T ;
      reg_b         : IN     register_T ;
      reg_c         : IN     register_T ;
      res_n         : IN     std_logic ;
      dc_alu_mode   : OUT    alu_mode_T ;
      dc_ctrl       : OUT    ctrl_signals_T ;
      dc_imm        : OUT    imm_12_bit_T ;
      dc_reg_a_data : OUT    dword_T ;
      dc_reg_b_data : OUT    dword_T ;
      dc_use_imm    : OUT    boolean 
   );
   END COMPONENT;
   COMPONENT ex_reg
   PORT (
      alu_out    : IN     dword_T;
      clk        : IN     std_logic;
      dc_ctrl    : IN     ctrl_signals_T;
      res_n      : IN     std_logic;
      ex_alu_out : OUT    dword_T;
      ex_ctrl    : OUT    ctrl_signals_T
   );
   END COMPONENT;
   COMPONENT if_reg
   PORT (
      clk        : IN     std_logic ;
      if_instr_d : IN     word_T ;
      res_n      : IN     std_logic ;
      if_ctrl    : OUT    ctrl_signals_T ;
      if_instr   : OUT    word_T 
   );
   END COMPONENT;
   COMPONENT instruction_memory
   PORT (
      addr  : IN     dword_T;
      clk   : IN     std_logic;
      instr : OUT    word_T;
      stall : OUT    boolean
   );
   END COMPONENT;
   COMPONENT me_reg
   PORT (
      clk        : IN     std_logic;
      ex_alu_out : IN     dword_T;
      ex_ctrl    : IN     ctrl_signals_T;
      res_n      : IN     std_logic;
      me_alu_out : OUT    dword_T;
      me_ctrl    : OUT    ctrl_signals_T
   );
   END COMPONENT;
   COMPONENT next_pc_mux
   PORT (
      dbta_valid        : IN     boolean;
      dynamic_branch_pc : IN     dword_T;
      incremented_pc    : IN     dword_T;
      sbta_valid        : IN     boolean;
      static_branch_pc  : IN     dword_T;
      next_pc           : OUT    dword_T
   );
   END COMPONENT;
   COMPONENT pc_incrementer
   PORT (
      pc      : IN     dword_T;
      next_pc : OUT    dword_T
   );
   END COMPONENT;
   COMPONENT pc_reg
   PORT (
      clk           : IN     std_logic ;
      current_pc_d  : IN     dword_T ;
      res_n         : IN     std_logic ;
      pc_current_pc : OUT    dword_T 
   );
   END COMPONENT;
   COMPONENT register_file
   PORT (
      clk          : IN     std_logic;
      reg_a_index  : IN     register_index_T;
      reg_b_index  : IN     register_index_T;
      reg_c_index  : IN     register_index_T;
      res_n        : IN     std_logic;
      write_index  : IN     register_index_T;
      write_reg    : IN     register_T;
      write_reg_en : IN     boolean;
      reg_a        : OUT    register_T;
      reg_b        : OUT    register_T;
      reg_c        : OUT    register_T
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : alu USE ENTITY riscvio_lib.alu;
   FOR ALL : alu_input_mux USE ENTITY riscvio_lib.alu_input_mux;
   FOR ALL : at_reg USE ENTITY riscvio_lib.at_reg;
   FOR ALL : dc_reg USE ENTITY riscvio_lib.dc_reg;
   FOR ALL : ex_reg USE ENTITY riscvio_lib.ex_reg;
   FOR ALL : if_reg USE ENTITY riscvio_lib.if_reg;
   FOR ALL : instruction_memory USE ENTITY riscvio_lib.instruction_memory;
   FOR ALL : me_reg USE ENTITY riscvio_lib.me_reg;
   FOR ALL : next_pc_mux USE ENTITY riscvio_lib.next_pc_mux;
   FOR ALL : pc_incrementer USE ENTITY riscvio_lib.pc_incrementer;
   FOR ALL : pc_reg USE ENTITY riscvio_lib.pc_reg;
   FOR ALL : register_file USE ENTITY riscvio_lib.register_file;
   -- pragma synthesis_on


BEGIN
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 1 eb1
   -- eb1 1      
   falsesig <= false;    
   zeroindex <= natural(0);                              


   -- Instance port mappings.
   alui : alu
      PORT MAP (
         a       => dc_reg_a_data,
         b       => b,
         mode    => dc_alu_mode,
         alu_out => alu_out,
         flags   => OPEN
      );
   U_1 : alu_input_mux
      PORT MAP (
         imm      => dc_imm,
         reg_data => dc_reg_b_data,
         use_imm  => dc_use_imm,
         b        => b
      );
   at_reg_i : at_reg
      PORT MAP (
         clk          => clk,
         me_alu_out   => me_alu_out,
         me_ctrl      => me_ctrl,
         res_n        => res_n,
         write_index  => write_index,
         write_reg    => write_reg,
         write_reg_en => write_reg_en
      );
   dc_reg_i : dc_reg
      PORT MAP (
         clk           => clk,
         if_ctrl       => if_ctrl,
         reg_a         => reg_a,
         reg_b         => reg_b,
         reg_c         => reg_c,
         res_n         => res_n,
         dc_alu_mode   => dc_alu_mode,
         dc_ctrl       => dc_ctrl,
         dc_imm        => dc_imm,
         dc_reg_a_data => dc_reg_a_data,
         dc_reg_b_data => dc_reg_b_data,
         dc_use_imm    => dc_use_imm
      );
   ex_reg_i : ex_reg
      PORT MAP (
         alu_out    => alu_out,
         clk        => clk,
         dc_ctrl    => dc_ctrl,
         res_n      => res_n,
         ex_alu_out => ex_alu_out,
         ex_ctrl    => ex_ctrl
      );
   if_reg_i : if_reg
      PORT MAP (
         clk        => clk,
         if_instr_d => if_instr_d,
         res_n      => res_n,
         if_ctrl    => if_ctrl,
         if_instr   => if_instr
      );
   U_0 : instruction_memory
      PORT MAP (
         clk   => clk,
         addr  => current_pc_d,
         instr => if_instr_d,
         stall => OPEN
      );
   me_reg_i : me_reg
      PORT MAP (
         clk        => clk,
         ex_alu_out => ex_alu_out,
         ex_ctrl    => ex_ctrl,
         res_n      => res_n,
         me_alu_out => me_alu_out,
         me_ctrl    => me_ctrl
      );
   next_pc_muxi : next_pc_mux
      PORT MAP (
         incremented_pc    => incremented_pc,
         static_branch_pc  => incremented_pc,
         dynamic_branch_pc => incremented_pc,
         dbta_valid        => falsesig,
         sbta_valid        => falsesig,
         next_pc           => current_pc_d
      );
   pc_increment_i : pc_incrementer
      PORT MAP (
         pc      => pc_current_pc,
         next_pc => incremented_pc
      );
   pc_reg_i : pc_reg
      PORT MAP (
         clk           => clk,
         current_pc_d  => current_pc_d,
         res_n         => res_n,
         pc_current_pc => pc_current_pc
      );
   U_2 : register_file
      PORT MAP (
         clk          => clk,
         res_n        => res_n,
         reg_a_index  => zeroindex,
         reg_b_index  => zeroindex,
         reg_c_index  => zeroindex,
         reg_a        => reg_a,
         reg_b        => reg_b,
         reg_c        => reg_c,
         write_reg_en => write_reg_en,
         write_index  => write_index,
         write_reg    => write_reg
      );

END struct;
