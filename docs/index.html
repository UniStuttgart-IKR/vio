<!DOCTYPE html>
<html lang="en">
<link rel="stylesheet" href="ieee.css">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RISC-ViO Spec</title>
</head>
<body>
    <header class="col-span page-break-after">
        <h2 class="subtitle counter-skip" style="margin-bottom: 0;"><em>The</em></h2>
        <h1 class="title counter-skip"><em>RISC-ViO</em></h1>
        <h2 class="subtitle counter-skip"><em>Specification</em></h2>
        <div class="authors col-2">
        <div class="author">
            <div>Leyla Jazz Ekinci (<em>B.Sc.</em>)</div>
            <div>University of Stuttgart, IKR</div>
            <div>Stuttgart, Germany</div>
            <div>email</div>
        </div>
        <div class="author">
            <div>Robin Lux (<em>B.Sc.</em>)</div>
            <div>University of Stuttgart, IKR</div>
            <div>Stuttgart, Germany</div>
            <div>email</div>
        </div>
        </div>
    </header>

    <h1 class="counter-skip page-break-before">Table of Contents</h1>
    <ul id="toc" class="toc" style="list-style-type:none; margin-left: 0;">
    </ul>

    <h1><a name="motivation">Motivation</a></h1>
    <section>
      <p>(max halbe seite, 2 bildchen konventionell vs objektorientiert)</p>
    </section>

    <h1><a name="base_spec">I' Instruction set</a></h1>
    <section>
      <p>- pointer vs daten (addi vs alci)<br>
         - Wie unterscheiden sich load/store befehle von herkömmlichen risc-v prozessoren</p>
    </section>

    <h1><a name="instructions">zhm Extension Instructions</a></h1>
    <section>
        <h2><a name="alc">alc/alci/alc.d/alci.d</a></h2>
        <h2><a name="qsz">qsz</a></h2>
        <h2><a name="dtp">dtp/btd/itd</a></h2>
        <h2><a name="lw_x">lw.x/sw.x</a></h2>
    </section>

    <h1><a name="instructions">Objects</a></h1>
    <section>
        <h2><a name="length">Length</a></h2>
        <h2><a name="pointers">Pointers</a></h2>
    </section>
    
    <h1><a name="frames">Linked Frames</a></h1>

        <h2><a name="are_obj">Structure</a></h2>
        <h2><a name="cc">Calling Convention</a></h2>
        <section>
            <h2><a name="protection">Frame Ownership</a></h2>
            <div style="position: relative; right: -5%; width: 90%">
                <p>//trivia about how accesses beyond stack frames are bad//</p>
                <p>In order to protect the stack frame of a function from modification by other functions, RISC-ViO introduces a scheme to protect these frames.
                This requires access management for those frames, which RISC-ViO implements in form of adding colour tags to both the sp as well as the ra register.
                By updating those colours at critical points such as function entries and frame allocations, the processor always knows whether the stack frame pointed to by the
                sp register is owned by the currently executed function. 
                This state is called "regular", while the current function not being the owner of the current stack frame is denoted as the "irregular" state.
                </p>
                <p>For sp aswell as for ra, there are two colours: black and white. Those colours are an integral part of those registers and cannot be read or modified seperately from their registers.
                Also, when storing/loading ra or sp using sw/lw, the colour is also stored/retrieved to/from the given memory location.
                    An overview of the transition between those colours is given in Figure 1.
                    On every function entry, the processor flips the colour of ra from white to black or vice-versa. For sp, this takes place on every stack frame allocation.
                    Whether the processor is currently in the regular state is given by the equality of the colours of ra and sp. 
                    If the colours of sp and ra both were black for example, the processor would be in the regular state.
                </p>
            </div>
            <figure>
                <figcaption>Colour transitions</figcaption>
                <div style="width: 100%; display: flex; justify-content: center;">
                    <div style="width: 80%; display: flex; justify-content: space-around; flex-direction: row;  flex-wrap: wrap;">
                        <div style="margin: 0px auto" >
                            <img src="svg/vio_stack_colors_transitions.drawio.svg" id="svg2" style="width: 20rem; margin: 0px auto; background-color: #FFFFFF;">
                        </div>
                    </div>
                </div>
            </figure>
            <div style="position: relative; right: -5%; width: 90%">
                <p>
                    Figure 2 provides two sample program flows for which the colour and therefore state transitions are also shown. 
                    Figure 2a) shows the behaviour of the colour mechanism during the execution of a correct stream of instructions while figure 2b) highlights how this mechanism catches bad program behaviour and the subsequent raising of the StateException. 
                </p>
            </div>
            <figure>
                <figcaption>Example state transitions</figcaption>
                <div style="width: 100%; display: flex; justify-content: center;">
                    <div style="width: 80%; display: flex; justify-content: space-around; flex-direction: row;  flex-wrap: wrap;">
                        <div style="margin: 0px auto" >
                            <img src="svg/vio_stack_colors.drawio.svg" id="svg1" style="margin: 0px auto; background-color: #FFFFFF;">
                            <p>a) Transitions during normal program flow</p>
                        </div>

                        <div style="margin: 0px auto" >
                            <img src="svg/vio_stack_colors_exception.drawio.svg" id="svg2" style="margin: 0px auto; background-color: #FFFFFF;">
                            <p>b) Transitions during abnormal program flow with exception</p>
                        </div>
                    </div>
                </div>
            </figure>

        </section>
    
    <h1><a name="got">Global Offset Table</a></h1>
    <section>
        <h2><a name="gp">Global Pointer</a></h2>
        <h2><a name="static">Accessing static objects</a></h2>
    </section>

    <p>
        1. Motivation
        (max halbe seite, 2 bildchen konventionell vs objektorientiert)

        2. Anpassungen an der Basisspec
        - pointer vs daten (addi vs alci)
        - Wie unterscheiden sich load/store befehle von herkömmlichen risc-v prozessoren

        3. Instruction Description
        3.1 alc/alci/alc.d/alci.d
        3.2 qsz
        3.3 dtp/btd/itd
        3.4 lw.x/sw.x

        4. Objekte
        4.1 Länge
        4.2 Pointer bleiben erhalten sowohl im Speicher als auch im RegFile

        5. Linked Frames
        5.1 Sind Objekte
        5.2 calling convention
        5.3 ra-/sp-schutz

        5. GOT-Inderiktionen
        5.1 gp-abstraktion (dass der immer auf die aktuelle got zeigt)
        5.2 wie wird auf statische/konstante objekte zugegriffen

        6. Exceptions
        6.1 mtvec, ... sind pointer
        6.2 Index Out Of Bounds Exception
        6.3 IncompatibleTypeException
        6.4 HeapOverFlowException
        6.5 StateException
        6.6 JumpIndexOutOfBoundsException

        --flavors of privileged violations
        6.7 GPAccessException
        6.8 ForbiddenSrcException
        6.9 ForbiddenDstException

        4. Objektstrukturen
        4.1 Header
        4.2 Elementtypen
        4.3 Ordinary Objects
        4.4 Executables
        4.5 Sanctuary Objects

        6. Register File
        6.1 Index and Length fields
        6.1 sp/ra coloring
        6.2 flags & tags

        7. Pointer- & Address-Generation
        7.1 Allocations
        7.2 loading/storing a pointer
        7.2 Bounds-Checks on object access

        X. Tabellen
        5.1 Instructions
        5.2 Object and Pointer Types
        5.3 Exceptions
        5.4 CSRs

        A1. Boot-Prozess

    </p>
</body>

<script>
    var h1Toc = document.getElementById('toc'); 
    var headerList = document.querySelectorAll("h1, h2");

    var lastWasH2 = false;
    var toc = h1Toc;
    var h1Numbering = 0;
    var h2Numbering = 0;
    for (var i = 0; i < headerList.length; i++) {
        var header = headerList[i];
        if (header.childNodes.length == 0 || header.childNodes[0].nodeName != "A")
            continue;

        if (h2Numbering == 0 && header.nodeName == "H2"){
            const h2Toc = document.createElement("ul");
            h2Toc.style.listStyleType = "none";
            h2Toc.style.marginLeft = 0;
            h1Toc.appendChild(h2Toc);
            toc = h2Toc;
        } else if (h2Numbering > 0 && header.nodeName == "H1"){
            toc = h1Toc;
            h2Numbering = 0;
        }

        if (header.nodeName == "H1")
            h1Numbering++;
        
        if (header.nodeName == "H2")
            h2Numbering++;

        const li = document.createElement("li");
        li.className = "toc";
        if (h2Numbering == 0){
            li.style.fontSize = "14pt";
            li.appendChild(document.createTextNode(h1Numbering + ". "));
        } else {
            li.style.fontSize = "12pt";
            li.appendChild(document.createTextNode(h1Numbering + "." + h2Numbering + ". "));
        }
        const link = header.childNodes[0].cloneNode(true);
        link.setAttribute("href", "#" + link.getAttribute("name"));
        link.setAttribute("class", "toc");
        link.setAttribute("name", null);
        li.appendChild(link);
        toc.appendChild(li);
    }
</script>
</html>