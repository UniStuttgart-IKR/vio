<!DOCTYPE html>
<html lang="en">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="misc/ieee.css">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RISC-ViO Spec</title>
</head>
<body>
    <header class="col-span page-break-after">
        <div class="subtitle counter-skip" style="margin-bottom: 0;"><em>The</em></div>
        <div class="title counter-skip"><em>RISC-ViO</em></div>
        <div class="subtitle counter-skip"><em>Specification</em></div>
        <h2 class="subtitle counter-skip"><em>Draft V0.0.1</em></h2>
        <div class="authors col-2">
        <div class="author">
            <div>Leyla Jazz Ekinci (<em>B.Sc.</em>)</div>
            <div>University of Stuttgart, IKR</div>
            <div>Stuttgart, Germany</div>
            <div>email</div>
        </div>
        <div class="author">
            <div>Robin Lux (<em>B.Sc.</em>)</div>
            <div>University of Stuttgart, IKR</div>
            <div>Stuttgart, Germany</div>
            <div>email</div>
        </div>
        </div>
    </header>

    <h1 class="counter-skip page-break-before" style="text-align: center;">Table of Contents</h1>
    <ul id="toc" class="toc page-break-after" style="list-style-type:none; margin-left: 0;">
    </ul>

    <h1><a id="motivation">Motivation</a></h1>
    <section>
        <p>
        In conventional computer architectures, the hardware has no information about the location and size of programming language level objects like strings, structs and so on.
        It is therefore the duty of the runtime of the used programming language to determine whether an access to one such object still lies within the bounds of this object and prohibit the access in case of a malformed access.
        This leads to an runtime overhead which reduces program efficiency.
        Also, in languages like C, those objects are identified using their address in form of a value only, the hardware therefore cannot distinguish between a reference to a high level object and some data value which might by chance have the value at which one such object lies.
        This ambiguity between pointers and values makes it impossible to garbage collect unused objects in memory which is why in C it is necessary for the programmer to manually manage, ie allocate and free memory.
        Being a difficult task to get right, this often leads to memory leaks. For this reason, other programming languages like Go store additional type information for every piece of data to distinguish between data and pointers.
        Since the hardware doesn't know about this additional information that the runtime has access to, it is not possible to accelerate the task of garbage collection in hardware and therefore reduce the incurred runtime penalties.
        </p>
        <p>
        To solve both of those problems, the inspiration for RISC-ViO, the experimental O-RISC architecture //cit here// introduces data type information to identify pointers as well as object size information on the ISA level while abstaining from tag bits.
        This enables both the enforcement of bounds checks as well as garbage collection in hardware, leading to more robust program execution as well as less runtime overhead.
        </p>
        (2 bildchen konventionell vs objektbasiert)
        <p>
        While the O-RISC architecture provides a solution to the problems identified above by providing a new perspective on the cooperation of hardware and software, it comes with some drawbacks.
        One of those drawbacks lies in the fact that O-RISC only allows pointers to the beginning of an object. 
        Indexing of an objects content is achieved by providing an offset inside the object via an additional value from a register.
        Accesses to data inside of objects in O-RISCV therefore are a two-step process.
        This in consequence makes O-RISC incompatible to the influental C programming language, reducing the amount of programs being source code compatible with this architecture. 
        RISC-ViO aims to provide both the pointer unambiguity as well as the bounds checks which O-RISC provides while still allowing for pointers inside of objects, enabling C compatibility.
        Furthermore, while O-RISC is a fully custom architecture with fully custom instruction format, RISC-ViO is based upon the open RISC-V architecture which allows for easier integration and expansion of this new architecture. 
        </p>
    </section>

    <h1><a id="base_spec">The RISC-V I' ISA</a></h1>
    <section>
        In order to enforce the usage of bounds checks and pointer unambiguity measures, RISC-ViO modifies some of the instructions which are part of the RISC-V I base instruction set.
        This alteration of the RISC-V base ISA is denoted as the RISC-V I' ISA.
        <h2><a id="data_vs_pointers">Values vs pointers</a></h2>
        <p>

        </p>
        <h2><a id="riscv_i_tick">RISC-V I vs I'</a></h2>
        <p>
        The most obviuos change is necessary in regard to load and store instructions. The main change for those instruction families lies in them requiring pointers to be used to select memory locations.
        Offsets from those pointers using the 12 bit immediates present in those instructions are still allowed. Arithmetic operations of those pointes like additions or subtractions are also still allowed and modify the pointer as a regular address would be modified by the executed operation.
        The base address information as well as the size information are not influenced by those operations however.    
        </p>
        <p>
        To enforce this new addressing scheme, the processor will raise a <em>IncompatibleTypeException</em> when a program tries to use a address value to access memory. Since the object attributes for every object referenced by a pointer are known, the processor is able to raise a <em>IndexOutBoundsException</em> when a out of bound load or store instruction is executed.
        <br>
        - pointer vs daten (addi vs alci)<br>
         - Wie unterscheiden sich load/store befehle von herkömmlichen risc-v prozessoren<br>
        - regular vs data only objects<br>
        - code objects (jalr vs jal)<br>
        - frame growth by allocation<br>
        </p>
    </section>

    <section>
    <h1><a id="instructions">The Zhm Extension</a></h1>
        <p>In addition to the modifications of already existing instructions which are part of the RISC-V I base ISA, RISC-ViO introduces several instructions as an interface between software and hardware regarding objects.
            Those instructions are all part of the zhm ("heap management") extension.
        </p>

        <h2><a name="unpriv_instructions">Unprivileged Instructions</a></h2>
        <h3><a name="alc_fam">Allocation: alc/alci/alc.d/alci.d</a></h3>
        Since RISC-ViO manages objects on the ISA level, the ISA has to provide a means to create new objects and their corresponding pointers.
        This creation of ISA level objects is achieved by the alc-Instruction family which comes in four flavours. 
        In fact the alc instruction family is the only way to obtain new pointers in user mode.
        The next section provides a short description of those instructions alongside their bit encodings.

        <h4><a name="alci">alci-Instruction</a></h4>
        The alci instruction is the most basic form in its family. This instruction allows the allocation of a regular object where the size of the object is given by the 12 bit wide immediate.
        This immediate specifies the amount of pointers which can fit inside the object.
        <div style="width: 100%; display: flex; justify-content: center;">
            <div style="width: 80%; display: flex; justify-content: space-around; flex-direction: row;  flex-wrap: wrap; margin: 30px">
                <img src="svg/alci_instr_bitmap.svg" id="svg2" style="width: 80%; margin: 0px auto;">
            </div>
        </div>
        The alci instruction may trigger the following exceptions for the given events:
        <ul>
            <li><em>HeapOverflowException</em>: Allocating the specified object would overflow the heap.</li>
            <li><em>GPAccessException</em>: rd is forbidden gp</li>
        </ul>

        <h4><a name="alc">alc-Instruction</a></h4>
            The alc instruction is a variation of the alci instruction. In contrast to alci, the size of the new object is given by the content of register rs1.
            The size is given in bytes as per the value in rs1.
            Apart from the source of the object size, alc only differs from alci in that alc cannot be used to allocate a frame. 
        <div style="width: 100%; display: flex; justify-content: center;">
            <div style="width: 80%; display: flex; justify-content: space-around; flex-direction: row;  flex-wrap: wrap; margin: 30px">
                <img src="svg/alc_instr_bitmap.svg" id="svg3" style="width: 80%; margin: 0px auto; color-scheme: light;">
            </div>
        </div>
        The alc instruction may trigger the following exceptions for the given events:
        <ul>
            <li><em>HeapOverflowException</em>: Allocating the specified object would overflow the heap.</li>
            <li><em>IncompatibleTypeException</em>: rs1 contains a pointer, not a value</li>
            <li><em>GPAccessException</em>: rd is forbidden gp</li>
        </ul>
        <h4><a name="alcid">alcid-Instruction</a></h4>
            The alcid instruction is a specialisation of the alci instruction. While alci allocates an object which may hold both pointers and data, objects created using alcid may only hold data.
            Also, using alcid to create a new frame is forbidden.
        <div style="width: 100%; display: flex; justify-content: center;">
            <div style="width: 80%; display: flex; justify-content: space-around; flex-direction: row;  flex-wrap: wrap; margin: 30px">
                <img src="svg/alcid_instr_bitmap.svg" id="svg2" style="width: 80%; margin: 0px auto; background-color: #FFFFFF;">
            </div>
        </div>
        The alcid instruction may trigger the following exceptions for the given events:
        <ul>
            <li><em>HeapOverflowException</em>: Allocating the specified object would overflow the heap.</li>
            <li><em>ForbiddenDstException</em>: rd is forbidden sp</li>
            <li><em>GPAccessException</em>: rd is forbidden gp</li>
        </ul>
        <h4><a name="alcd">alcd-Instruction</a></h4>
            The alcd instruction is the analogous form of alc regarding data only objects. It differs in the type of allocated object and in that it also is prohibited from allocting frames.
        <div style="width: 100%; display: flex; justify-content: center;">
            <div style="width: 80%; display: flex; justify-content: space-around; flex-direction: row;  flex-wrap: wrap; margin: 30px">
                <img src="svg/alcd_instr_bitmap.svg" id="svg2" style="width: 80%; margin: 0px auto; background-color: #FFFFFF;">
            </div>
        </div>
        The alcd instruction may trigger the following exceptions for the given events:
        <ul>
            <li><em>HeapOverflowException</em>: Allocating the specified object would overflow the heap.</li>
            <li><em>IncompatibleTypeException</em>: rs1 contains a pointer, not a value</li>
            <li><em>ForbiddenDstException</em>: rd is forbidden sp</li>
            <li><em>GPAccessException</em>: rd is forbidden gp</li>
        </ul>
        <h3><a name="qsz">Attribute Query: qsz</a></h3>
        The qsz instruction proviodes a means of reading an objects size as specified at its allocation time in bytes. For this, the source register has to contain a pointer.
        <div style="width: 100%; display: flex; justify-content: center;">
            <div style="width: 80%; display: flex; justify-content: space-around; flex-direction: row;  flex-wrap: wrap; margin: 30px">
                <img src="svg/qsz_instr_bitmap.svg" id="svg2" style="width: 80%; margin: 0px auto; background-color: #FFFFFF;">
            </div>
        </div>
        The qsz instruction may trigger the following exceptions for the given events:
        <ul>
            <li><em>IncompatibleTypeException</em>: rs1 contains a pointer, not a value</li>
            <li><em>ForbiddenDstException</em>: rd is sp which only takes pointers</li>
            <li><em>GPAccessException</em>: rd is forbidden gp</li>
        </ul>
        <h2><a name="priv_instructions">Privileged Instructions</a></h2>
        <h3><a name="dtp">Raw Pointer Access: dtp/btd/itd</a></h3>
        <h3><a name="lw_x">Raw Memory Access: lw.x/sw.x</a></h3>
    </section>

    <h1><a name="objects">Objects</a></h1>
    <section>
    </section>
    
    <h1><a name="frames">The not so stacked frames</a></h1>

        <h2><a name="are_obj">Structure</a></h2>
        <h2><a name="cc">Calling Convention</a></h2>
        <section>
            <h2><a name="protection">Frame Ownership</a></h2>
                <p>In order to protect the frame of a function from modification by other functions, RISC-ViO introduces a scheme to protect these frames.
                This requires access management for those frames, which RISC-ViO implements in form of adding colour tags to both the sp as well as the ra register.
                By updating those colours at critical points such as function entries and frame allocations, the processor always knows whether the frame pointed to by the
                sp register is owned by the currently executed function. 
                This state is called "regular", while the current function not being the owner of the current frame is denoted as the "irregular" state.
                </p>
                <p>For sp as well as for ra, there are two colours: black and white. Those colours are an integral part of those registers and cannot be read or modified seperately from their registers.
                Also, when storing/loading ra or sp using sw/lw, the colour is also stored/retrieved to/from the given memory location.
                    An overview of the transition between those colours is given in Figure 1.
                    On every function entry, the processor flips the colour of ra from white to black or vice-versa. For sp, this takes place on every frame allocation.
                    Whether the processor is currently in the regular state (light blue), is given by the equality of the colours of ra and sp. 
                    If the colours of sp and ra both were black for example, the processor would be in the regular state.
                </p>
                <p>
                    Any access to the current frame while in irregular state leads to a <em>StateException</em> indicating access to a foreign frame.
                </p>
            <figure>
                <figcaption>Colour transitions</figcaption>
                <div style="width: 100%; display: flex; justify-content: center;">
                    <div style="width: 80%; display: flex; justify-content: space-around; flex-direction: row;  flex-wrap: wrap;">
                        <div style="margin: 0px auto" >
                            <img src="svg/vio_stack_colors_transitions.drawio.svg" id="svg2" style="width: 20rem; margin: 0px auto;">
                        </div>
                    </div>
                </div>
            </figure>
                <p>
                    Figure 2 provides two sample program flows for which the colour and therefore state transitions are shown. 
                    Figure 2a) shows the behaviour of the colour mechanism during the execution of a correct stream of instructions while figure 2b) highlights how this mechanism catches bad program behaviour. 
                    In 2b) the colour mechanism spots function b trying to access function a's frame, which leads to the processor raising a <em>StateException</em>.
                </p>
            <figure>
                <figcaption>State transitions for examplatory instruction streams</figcaption>
                <div style="display: flex; margin-top: 14pt; margin-bottom: 28pt;">
                    <img src="svg/vio_stack_colors.drawio.svg" id="svg1" style="flex: 50%; margin-right: 10pt;">
                    <img src="svg/vio_stack_colors_exception.drawio.svg" id="svg2" style="flex: 50%; margin-left: 10pt; align-self: baseline;">
                </div>
                <div style="display: flex;">
                    <p style="flex: 50%; margin-right: 10pt;">a) Transitions during normal program flow</p>
                    <p style="flex: 50%; margin-left: 10pt;">b) Transitions during abnormal program flow with exception</p>
                </div>
            </figure>
        </section>
    
    <h1><a id="got">Global Offset Table</a></h1>
    <h2><a id="gp">Global Pointer</a></h2>
    <section>
    </section>
    <h2><a id="static">Accessing static objects</a></h2>
    <section>
    </section>
    
    <h1><a id="exceptions">Exceptions</a></h1>
    <h2><a id="gen">General</a></h2>
        <p>Since RISC-ViO allows both pointers as well as regular data to be stored in the registers and also organizes code using objects, some CSR also need to be able to hold pointers.
            This is the case for <em>xtvec</em> and <em>xepc</em> due to code objects and for <em>xtval</em> and <em>xscratch</em> due to pointers in general.
            To access the components of these registers, the <em>csrw</em> instruction may be used in conjunction with the <em>dtp</em>/<em>btd</em>/<em>itd</em> instructions.
        </p>
    <section>

    </section>
    <h2><a id="priv">Privilege Violations</a></h2>
    <section>
    <p><a href="#t_csr">Table XX</a> provides an overview of the exceptions corresponding to the protection schemes introduced by RISC-ViO.
        In order to allow higher priviledge modes to gain the access required for system management, some exceptions are supressed in certain privilege modes.</p>
        
    </section>

    <h1><a id="hard_obj">Hardwares view on Objects</a></h1>
    <h2><a id="headers">Headers</a></h2>
    <section>
    </section>
    <h2><a id="elements">Elements</a></h2>
    <section>
    </section>
    <h2><a id="ords">Ordinaries</a></h2>
    <section>
    </section>
    <h2><a id="execs">Executables</a></h2>
    <section>
    </section>
    <h2><a id="sancts">Sanctuaries</a></h2>
    <section>
    </section>

    <h1><a id="reg_fl">How a Register File could look like</a></h1>
    <h2><a id="fields">Fields</a></h2>
    <section>
    </section>
    <h2><a id="coloring">Coloring</a></h2>
    <section>
    </section>
    <h2><a id="flgs_tgs">Flags and Tags</a></h2>
    <section>
    </section>

    <h1><a id="ptr_addr">Pointer and Address generation</a></h1>
    <h2><a id="alcs">Allocations</a></h2>
    <section>
    </section>
    <h2><a id="load_store">Loading and Storing a Pointer</a></h2>
    <section>
    </section>
    <h2><a id="bounds">Bounds Checks</a></h2>
    <section>
    </section>

    <h1><a id="tables">Tables</a></h1>
    <h2><a id="t_inst">Instructions</a></h2>
    <section>
    </section>
    <h2><a id="t_op">Object and Pointer Types</a></h2>
    <section>
    </section>
    <h2><a id="t_exc">Exceptions</a></h2>
    <section>
        <table summary="Exceptions and their numbers for privilege modes" style="margin-bottom: 0;">
            <thead>
            <tr>
                <th rowspan="2">
                    <em>xcause index</em>
                </th>
                <th rowspan="2">
                    <em>Name</em>
                </th>
                <th colspan="3">
                    <em>may be raised in privilege mode</em>
                </th>
            </tr>
            <tr>
                <th><em>user</em></th>
                <th><em>supervisor</em></th>
                <th><em>machine</em></th>
            </tr>
            <tr>
                <th>16</th>
                <th>JumpIndexOutBoundsException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✔</th>
            </tr>
            <tr>
                <th>17</th>
                <th>GPAccessException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>18</th>
                <th>IndexOutBoundsException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>19</th>
                <th>HeapOverflowException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>20</th>
                <th>StateException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>21</th>
                <th>ForbiddenSrcException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>22</th>
                <th>ForbiddenDstException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>23</th>
                <th>IncompatibleTypeException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
        </thead>
        <tbody>

        </tbody>
        </table>
    </section>
    <h2><a id="t_csr">CSRs</a></h2>
    <section>
        <table summary="CSR added by zhm extension" style="margin-bottom: 0;">
            <thead>
            <tr>
                <th rowspan="2">
                    <em>CSR index</em>
                </th>
                <th rowspan="2">
                    <em>Name</em>
                </th>
                <th colspan="2">
                    <em>subfields</em>
                </th>
            </tr>
            <tr>
                <th><em>ptr</em></th>
                <th><em>index</em></th>
            </tr>
            <tr>
                <th>0xBC0</th>
                <th>MALC</th>
                <th>current allocation address</th>
                <th>heap end adress</th>
            </tr>
            <tr>
                <th>0xBC1</th>
                <th>MSAD</th>
                <th>free index in sanctuary object</th>
                <th>address of current sanctuary object</th>
            </tr>
           
        </thead>
        <tbody>

        </tbody>
        </table>
    </section>
    
    <h1><a id="appendix">Appendix</a></h1>
    <h2><a id="boot">Boot Process</a></h2>
    <section>
    </section>
</body>

<script>
    var h1Toc = document.getElementById('toc'); 
    var headerList = document.querySelectorAll("h1, h2");

    var lastWasH2 = false;
    var toc = h1Toc;
    var h1Numbering = 0;
    var h2Numbering = 0;
    for (var i = 0; i < headerList.length; i++) {
        var header = headerList[i];
        if (header.childNodes.length == 0 || header.childNodes[0].nodeName != "A")
            continue;

        if (h2Numbering == 0 && header.nodeName == "H2"){
            const h2Toc = document.createElement("ul");
            h2Toc.style.paddingInlineStart = "28pt";
            h2Toc.style.listStyleType = "none";
            h2Toc.style.marginLeft = 0;
            h1Toc.appendChild(h2Toc);
            toc = h2Toc;
        } else if (h2Numbering > 0 && header.nodeName == "H1"){
            toc = h1Toc;
            h2Numbering = 0;
        }

        if (header.nodeName == "H1")
            h1Numbering++;
        
        if (header.nodeName == "H2")
            h2Numbering++;

        const li = document.createElement("li");
        li.className = "toc";
        if (h2Numbering == 0){
            li.style.fontSize = "14pt";
            li.style.fontWeight = "bold";
            li.appendChild(document.createTextNode(h1Numbering + ". "));
        } else {
            li.style.fontSize = "12pt";
            li.style.fontWeight = "normal";
            //li.appendChild(document.createTextNode(h1Numbering + "." + h2Numbering + ". "));
        }
        const link = header.childNodes[0].cloneNode(true);
        link.setAttribute("href", "#" + link.getAttribute("id"));
        link.setAttribute("class", "toc-link");
        link.setAttribute("id", null);
        li.appendChild(link);
        toc.appendChild(li);
    }
</script>
</html>