<!DOCTYPE html>
<html lang="en">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="misc/ieee.css">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RISC-ViO Spec</title>
</head>
<body>
    <header class="col-span page-break-after">
        <div id="title" class="subtitle counter-skip" style="margin-bottom: 0;"><em>The</em></div>
        <div class="title counter-skip"><em>RISC-ViO</em></div>
        <div id="title-spec" class="subtitle counter-skip"><em>Specification</em></div>
        <h5  id="version" class="subtitle counter-skip" style="font-size: 18pt;"><em>DRAFT V0.0.1</em></h2>
        <div class="authors col-2">
        <div class="author">
            <div>Leyla Jazz Ekinci (<em>B.Sc.</em>)</div>
            <div>University of Stuttgart, IKR</div>
            <div>Stuttgart, Germany</div>
            <div>leylknci@ikr.uni-stuttgart.de</div>
        </div>
        <div class="author">
            <div>Robin Lux (<em>B.Sc.</em>)</div>
            <div>University of Stuttgart, IKR</div>
            <div>Stuttgart, Germany</div>
            <div>rbnlux@ikr.uni-stuttgart.de</div>
        </div>
        </div>
    </header>

    <h1 class="counter-skip page-break-before" style="text-align: center;">Table of Contents</h1>
    <ul id="toc" class="toc page-break-after" style="list-style-type:none; margin-left: 0;">
    </ul>

    <h1><a id="intro">Introduction</a></h1>
    <section>
        <h2><a id="motivation">Motivation</a></h2>
        <p>
            In conventional computer architectures, hardware has no information about the location and size of programming language level objects like strings or structs.
            It is therefore the duty of a runtime environment to define and enforce boundaries to such objects and prohibit malformed accesses.
            Obviously this comes with a substantial tradeoff in program efficiency.<br>
            Also, programming languages like C do not strictly differentiate between a reference to objects and values of primitive types. It could be that by chance the
            value of an integer points to the start of an object in memory, even though it was not intended to be used as a pointer.
            This ambiguity between pointers and values makes it impossible to use garbage collection mechanisms, making it the job of the programmer
            to manually free up memory. Being a difficult task to get right, this often leads to memory leaks.
        </p>
        <p>
            To tackle both of those challenges, the experimental <a href="#meyer_orisc">Objective-RISC architecture</a> (O-RISC), the inspiration of RISC-ViO, proposes a new perspective 
            on the cooperation of hardware and software. The main idea is to lower the concept of objects from a runtime level to the ISA. For this to work an O-RISC
            processor always has access to information strictly identifying pointers and boundaries of objects for every instruction executed.
            This enables the enforcement of bounds checks, prohibition of unwanted data modification and garbage collection in hardware, leading to more robust program execution
            as well as less runtime overhead.
        </p>
        <figure>
            <figcaption>View of the different architectures on programming language level objects in memory</figcaption>
            <div style="display: flex; margin-top: 14pt; margin-bottom: 28pt;">
                <img src="svg/conv_obj_view.drawio.svg" id="svg2" style="flex: 33%; margin: 10pt; height: 20rem">
                <img src="svg/oriscv_obj_view.drawio.svg" id="svg3" style="flex: 33%; margin: 10pt; height: 20rem">
                <img src="svg/vio_obj_view.drawio.svg" id="svg4" style="flex: 33%; margin: 10pt; height: 20rem">
            </div>
            <div style="display: flex;">
                <p style="flex: 33%; margin: 10pt;">a) Conventional architectures</p>
                <p style="flex: 33%; margin: 10pt;">b) O-RISC</p>
                <p style="flex: 33%; margin: 10pt;">c) RISC-ViO</p>
            </div>
        </figure>
        <p>
            Being the nature of groundbreaking concepts, O-RISC is designed to be very cautious about its new responsibilities.
            One area where this can be easily observed is O-RISCs postulation that pointers cannot be modified in any shape or form.
            To index contents of an object, compilers are required to keep a separate data register next to the original pointer register.
            This contradicts the assumptions many compilers make of computer architectures. LLVMs <em>getelementptr</em> instruction <a href="#llvm_gep">2</a> is one example
            where the assumptions O-RISC and a compiler take from one another can diverge.
            This in consequence makes O-RISC unable to compile the influential C programming language, reducing the amount of programs
            being source code compatible with this architecture.
        </p>
    </section>
    <section>
        <h2><a id="goals">Design Goals</a></h2>
        <p>
            As all children try to grow up to be a better version of their parents, RISC-ViO takes over O-RISCs belief in the new way of hardware-software
            cooperation, but draws its own set of conclusions:
        </p>
        <h4 style="text-indent: 0;">1. Make software more robust while keeping compatibility</h4>
        <p style="text-indent: 0;">
            RISC-ViO aims to provide the same unambiguousness and integrity of pointers as well as bounds checks of hardware objects which O-RISC provides.
            Unlike O-RISC however, RISC-ViO aims to reduce the impact on existing software to a minimum. The only changes necessary should to stay 
            on the side of runtimes and operating systems. User code should be able to  stay as is while still benefiting from RISC-ViOs advantages.
        </p>
        <h4 style="text-indent: 0;">2. Make the life of compilers easier</h4>
        <p style="text-indent: 0;">
            With the introduction of hardware heap management, RISC-ViO is raising the abstraction layer of memory. Consequently the effort of lowering higher  
            programming languages to machine instructions is dramatically reduced. This opens up new possibilities for improvements in how software can be compiled. 
            We aim to strengthen these benefits without limiting the already existing possibilities of compilers.
        </p>
        <h4 style="text-indent: 0;">3. Stay true to the RISC philosophy</h4>
        <p style="text-indent: 0;">
            The benefits of robustness are worthless when they come at the cost of arbitrary execution times. That is why RISC-ViO is designed in such a way
            that all instructions can be executed in a single clock cycle. This allows secure object-based programming with concurrent garbage collection on real-time systems.
        </p>
        <h4 style="text-indent: 0;">4. Be an extension, not a replacement</h4>
        <p style="text-indent: 0;">
            We propose a way the RISC-V Instruction Set Architecture can be extended without limiting other extensions or future innovation.
            This way, the idea of object-based architectures can be easily explored on a wide range of processor configurations. Reaching from minimal embedded
            applications, over vector-supporting AI-Units to fully fletched, state of the art multicore, superscalar CPUs. At the same time, other researchers can easily pick up ViO
            and make use of its benefits for their own purposes.
        </p>
    </section>


    <section>
        <h1><a id="chap_objects">Objects</a></h1>
        <p>
            In RISC-ViO, Objects are leveraged as the way to achieve the design goals outlined in the motivational chapter.
            Objects are unique, bounded areas allocated in memory that are referenced by pointers. 
            {heap?}Objects are defined by their type and their length.<br>
            On ISA-Level we differentiate between two types of objects: "Ordinary"-Objects and "Executable"-Objects.
        </p>
        <h2><a id="objs_ords">Ordinaries</a></h2>
        <p>
            Ordinary objects can be generated by allocate instructions provided by the <a href="#unpriv_instructions">zhm extension</a>. One can load and store Data from/to ordinary
            objects, however it is forbidden to execute their contents.<br>
            A special type of ordinaries are "data-only"-objects. As the name suggests, these objects can only contain primitives, but no pointers. If it is already known at compile-time
            that a certain object only contains primitive types, like strings or arrays, data-only objects allow for fast and compact memory access.
        </p>

        <h2><a id="objs_execs">Executables</a></h2>
        <p>
            Executables are objects that contain machine instructions. One cannot load and store Data from/to ordinary objects, however their contents can be executed.<br>
            First, Executables are allocated by the operating system as an ordinary, data-only object. Next the contents of the Executable are copied from their source to the Object.
            Finally the operating system changes the type of the object to executable.
        </p>
    </section>

    <section>
    <h1><a id="base_spec">The RISC-V I' ISA</a></h1>
        <p>
            In order to achieve the design goals at hand, RISC-ViO is forced to alter the semantics of some of the instructions which are part of the RISC-V I base instruction set.
            This alteration of the RISC-V base ISA is denoted as the RISC-V I' ISA. 
        </p>
        <h2><a id="data_vs_pointers">Values vs pointers</a></h2>
          <u>Contents of objects can only
        be written, read or executed using the pointer generated by the allocation instruction of the desired object. Pointers to objects cannot be generated by arithmetic operations.</u>{duplicated from i tick / zhm}
        <p>
            In order to restrict access of a program to the memory which contains the objects the program has pointers to, the I' ISA differentiates between values and pointers.
            Only pointers may be used to access memory as well as I/O devices. Those pointers can be obtained via the alc instruction family or by being manually created and subsequentially being passed down by higher privilege modes. 
            Note that pointers may not be written to I/O devices. This simplification reduces the complexity of the task of garbage collection.
            Pointers are to be encoded in such a way as to allow for objects to lie in the entire address space of the processor of XLEN bits.
        </p>
        <h2><a id="riscv_i_tick">RISC-V I vs I'</a></h2>
        <p>
        The most obvious change is necessary in regard to load and store instructions as listed below:
        </p>
        <ul style="list-style-position: inside; padding-left: 0; text-align:center">
            <li style="display: inline; padding-right: 2em;">◈ lb/lbu</li>
            <li style="display: inline; padding-right: 2em;">◈ lh/lhu</li>
            <li style="display: inline; padding-right: 2em;">◈ lw</li>
            <li style="display: inline; padding-right: 2em;">◈ sb</li>
            <li style="display: inline; padding-right: 2em;">◈ sh</li>
            <li style="display: inline; padding-right: 2em;">◈ sw</li>
        </ul>

        <p>
         The main change for those instruction families lies in them requiring pointers to be used to select objects instead of memory locations.
        Offsets from those pointers using the 12 bit immediate present in those instructions are still allowed. 
        Those offsets are added to the index of the pointer used to access the object to make up the offset used for the actual object access.</p>
        <!--@Leyla: wenn man unsere regeln bricht, tritt eine hardware exception-->
        <p>
        Arithmetic operations of those pointers like additions or subtractions are also still allowed and modify the pointer as a regular address would be modified by the executed operation.
        The base address information as well as the size information are not influenced by those operations, however. Note that for arithmetic operations on two pointers, rd will take on the pointer, length and header field of that pointer of that object inside of which the operation result lies. 
        Should the result not fall into either of the input objects, the behavior regarding which input is used for the pointer, length and header fields of the output register is undefined.
        </p>
        <!--@Leyla: Bild erstellen!-->
        <p>
        Since instructions are managed using executable objects, the semantics of even more instructions have to be altered:
        </p>
        <ul style="list-style-position: inside; padding-left: 0; text-align:center">
            <li style="display: inline; padding-right: 2em;">◈ auipc</li>
            <li style="display: inline; padding-right: 2em;">◈ jalr</li>
            <li style="display: inline; padding-right: 2em;">◈ jal</li>
        </ul>
        <p>
        The <em>auipc</em> instruction for example will emit a pointer instead of a value. 
        Due to the access to executable objects being limited as described in the <a href="#objs_execs">executable objects</a> chapter however, access to constant data is not possible using  this pointer.
        </p>
        <p>
        The encapsulation of instructions also means that the <em>jalr</em> instructions expects a pointer to a object containing instructions as a jump target to be written to the program counter.
        This instruction will also, just as <em>jal</em> does, write a pointer to its destination register.
        If the pointer provided does not reference such an object, the processor raises a <em>IncompatibleTypeException</em> with <em>xtval</em> containing the target pointer.
        Using a value as a destination for <em>jalr</em> is still allowed though and leads to jumping to the given index inside the currently executed code object.
        To make sure that a return address cannot be used twice, RISC-ViO mandates that the variant of <em>jalr</em> which realizes the <em>ret</em> pseudo instruction has to null out the register <em>ra</em> except for the zero-bit of its index after updating the program counter.
        </p>

        <h2><a id="riscv_i_tick">Register File</a></h2>
            </p>
            RISC-V specifies 31 general-purpose registers and one special register, <em>zero</em>.
            The RISC-ViO architecture adds additional requirements to this register file definition:
                <ul>
                    <li><em>zero</em> has to contain the value 0.</li>
                    <li>each register has to be able to hold either a value of width XLEN or a pointer with a XLEN wide index.</li>
                    <li>both <em>ra</em> and <em>sp</em> have to be able to hold colour information.</li>
                </ul>
            <p>
        </p>
    </section>




    <section>
    <h1><a id="instructions">The Zhm Extension</a></h1>
        <p>In addition to the modifications of already existing instructions which are part of the RISC-V I base ISA, RISC-ViO introduces several instructions as an interface between software and hardware regarding objects.
            Those instructions are all part of the zhm ("heap management") extension.
        </p>

        <h2><a name="unpriv_instructions">Unprivileged Instructions</a></h2>
        <h3><a name="alc_fam">Allocation: alc/alci/alc.d/alci.d</a></h3>
        Since RISC-ViO manages objects on the ISA level, the ISA has to provide a means to create new objects and their corresponding pointers.
        In contrast to the automatic freeing of unnecessary objects, this creation of ISA level objects is achieved by the alc-instruction family which comes in four flavours. 
        In fact the alc instruction family is the only way to obtain new pointers in user mode.
        The next section provides a short description of those instructions alongside their bit encodings.
        The objects allocated by the alc-instruction family are both readable and writeable but not executable on allocation. 

        <h4><a name="alc">alc-Instruction</a></h4>
            The alc instruction is the most basic form in its family. This instruction allows the allocation of a regular object where the size of the object is by the value passed via rs1.
            The size is given in bytes as per the value in rs1.
            Apart from the source of the object size, alc only differs from alci in that alc cannot be used to allocate a frame. 
            
            <div style="margin-top: 5%; margin-bottom: 3%;">
                <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                    <colgroup>
                        <col width="20%"/>
                        <col width="13%"/>
                        <col width="14%"/>
                        <col width="8%"/>
                        <col width="14%"/>
                        <col width="20%"/>
                    </colgroup>
                    <thead>
                        <th style="border-style:solid; border-width: 0px;">
                                <div style="float: left">31</div><div style="float: right">25</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">24</div><div style="float: right">20</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">19</div><div style="float: right">15</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">14</div><div style="float: right">12</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">11</div><div style="float: right">7</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">6</div><div style="float: right">0</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            Instruction
                        </th>
                    </thead>
                    <tbody>
                        <tr  style="float: center">
                            <td>0000000</td><td>0000</td><td>rs1(src)</td><td>000</td><td>rd(dst)</td><td>0001011</td><td>alc</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        The alc instruction may trigger the following exceptions for the given events (xtval content):
        <ul>
            <li><em>HeapOverflowException</em>: Allocating the specified object would overflow the heap. (object_size as value)</li>
            <li><em>IncompatibleTypeException</em>: rs1 contains a pointer, not a value (rs1)</li>
            <li><em>GPAccessException</em>: rd is forbidden gp (-)</li>
        </ul>

        <h4><a name="alci">alci-Instruction</a></h4>
        The alci instruction is a variation of the alc instruction. In contrast to alci, the size of the new object is given by the 12 bit wide immediate. 
        This immediate specifies the amount of pointers which can fit inside the object. So for a XLEN of 32, it specifies the number of 32 bit words that fit into the object.
        <div style="margin-top: 5%; margin-bottom: 3%;">
            <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                <colgroup>
                    <col width="20%"/>
                    <col width="13%"/>
                    <col width="14%"/>
                    <col width="8%"/>
                    <col width="14%"/>
                    <col width="20%"/>
                </colgroup>
                <thead>
                    <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">31</div><div style="float: right">25</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">24</div><div style="float: right">20</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">19</div><div style="float: right">15</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">14</div><div style="float: right">12</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">11</div><div style="float: right">7</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">6</div><div style="float: right">0</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        Instruction
                    </th>
                </thead>
                <tbody>
                    <tr  style="float: center"></tr>
                        <td colspan="2">imm[13:2]</td><td>00010</td><td>010</td><td>rd(dst)</td><td>0001011</td><td>alci</td>
                    </tr>
                </tbody>
            </table>
        </div>
        <p>When the alci instruction is used to allocate a frame by specifying sp as the destination register, its semantic is extended. In this case alci not only allocates a new frame object but also stores the old sp at index zero of the new frame object.</p>
        The alci instruction may trigger the following exceptions for the given events (xtval content):
        <ul>
            <li><em>HeapOverflowException</em>: Allocating the specified object would overflow the heap. (object_size as value)</li>
            <li><em>GPAccessException</em>: rd is forbidden gp (-)</li>
        </ul>

        <h4><a name="alcd">alcd-Instruction</a></h4>
            The alcd instruction is a specialization of the alc instruction, allowing for the allocation of data only objects.
            Note that is it also forbidden to use <em>alcd</em> to allocate a new frame object.
            <div style="margin-top: 5%; margin-bottom: 3%;">
                <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                    <colgroup>
                        <col width="20%"/>
                        <col width="13%"/>
                        <col width="14%"/>
                        <col width="8%"/>
                        <col width="14%"/>
                        <col width="20%"/>
                    </colgroup>
                    <thead>
                        <th style="border-style:solid; border-width: 0px;">
                                <div style="float: left">31</div><div style="float: right">25</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">24</div><div style="float: right">20</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">19</div><div style="float: right">15</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">14</div><div style="float: right">12</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">11</div><div style="float: right">7</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">6</div><div style="float: right">0</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            Instruction
                        </th>
                    </thead>
                    <tbody>
                        <tr  style="float: center"></tr>
                            <td>0000000</td><td>0000</td><td>rs1(src)</td><td>001</td><td>rd(dst)</td><td>0001011</td><td>alcd</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        The alc.d instruction may trigger the following exceptions for the given events (xtval content):
        <ul>
            <li><em>HeapOverflowException</em>: Allocating the specified object would overflow the heap. (object_size as value)</li>
            <li><em>IncompatibleTypeException</em>: rs1 contains a pointer, not a value (rs1)</li>
            <li><em>ForbiddenDstException</em>: rd is forbidden sp (-)</li>
            <li><em>GPAccessException</em>: rd is forbidden gp (-)</li>
        </ul>

        <h4><a name="alcid">alci.d-Instruction</a></h4>
        The alci.d instruction is the analogous form of alci regarding data only objects. It differs in the type of allocated object and in that it also is prohibited from allocating frames.
        <div style="margin-top: 5%; margin-bottom: 3%;">
            <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                <colgroup>
                    <col width="20%"/>
                    <col width="13%"/>
                    <col width="14%"/>
                    <col width="8%"/>
                    <col width="14%"/>
                    <col width="20%"/>
                </colgroup>
                <thead>
                    <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">31</div><div style="float: right">25</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">24</div><div style="float: right">20</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">19</div><div style="float: right">15</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">14</div><div style="float: right">12</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">11</div><div style="float: right">7</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">6</div><div style="float: right">0</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        Instruction
                    </th>
                </thead>
                <tbody>
                    <tr  style="float: center"></tr>
                        <td colspan="2">imm[13:2]</td><td>00010</td><td>011</td><td>rd(dst)</td><td>0001011</td><td>alcid</td>
                    </tr>
                </tbody>
            </table>
        </div>
        The alci.d instruction may trigger the following exceptions for the given events (xtval content):
        <ul>
            <li><em>HeapOverflowException</em>: Allocating the specified object would overflow the heap. (object_size as value)</li>
            <li><em>ForbiddenDstException</em>: rd is forbidden sp (-)</li>
            <li><em>GPAccessException</em>: rd is forbidden gp (-)</li>
        </ul>
        <h3><a name="qsz">Attribute Query: qsz</a></h3>
        The qsz instruction provides a means of reading an objects size as specified at its allocation time in bytes. For this, the source register has to contain a pointer.
        <div style="margin-top: 5%; margin-bottom: 3%;">
            <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                <colgroup>
                    <col width="20%"/>
                    <col width="13%"/>
                    <col width="14%"/>
                    <col width="8%"/>
                    <col width="14%"/>
                    <col width="20%"/>
                </colgroup>
                <thead>
                    <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">31</div><div style="float: right">25</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">24</div><div style="float: right">20</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">19</div><div style="float: right">15</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">14</div><div style="float: right">12</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">11</div><div style="float: right">7</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">6</div><div style="float: right">0</div>
                    </th>
                    <th style="border-style:solid; border-width: 0px;">
                        Instruction
                    </th>
                </thead>
                <tbody>
                    <tr  style="float: center"></tr>
                        <td>0000000</td><td>0000</td><td>rs1(src)</td><td>100</td><td>rd(dst)</td><td>0001011</td><td>qsz</td>
                    </tr>
                </tbody>
            </table>
        </div>
        The qsz instruction may trigger the following exceptions for the given events (xtval content):
        <ul>
            <li><em>IncompatibleTypeException</em>: rs1 contains a pointer, not a value (rs1)</li>
            <li><em>ForbiddenDstException</em>: rd is sp which only takes pointers (-)</li>
            <li><em>GPAccessException</em>: rd is forbidden gp (-)</li>
        </ul>
        <h2><a name="priv_instructions">Privileged Instructions</a></h2>
            With the instructions described above, it is impossible to break out of the restrictions given by the bounds check and pointer integrity safety measures. To enable the management of the processor system additional instructions are available for all privilege modes above the user mode.
        <h3><a name="dtp">Raw Pointer Access: dtp/btd/itd</a></h3>
            In order to be able to create and inspect pointers a total of three instructions are provided. These allow for both reading out the integral parts of a pointer as well as creating arbitrary pointers.
            <h4><a name="dtp">dtp-Instruction</a></h4>
            The dtp "data to pointer" instruction allows the assembly of arbitrary pointers. Both the index as well as the raw pointer value are set according the values in registers rs1 and rs2 respectively. The result is stored in rd. 
            Pointers assembled using <em>dtp</em> may be of ordinary and I/O pointer type. The tag values required for these types are shown in the <a href="#t_op">object and pointer overview</a>.
            <div style="margin-top: 5%; margin-bottom: 3%;">
                <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                    <colgroup>
                        <col width="20%"/>
                        <col width="13%"/>
                        <col width="14%"/>
                        <col width="8%"/>
                        <col width="14%"/>
                        <col width="20%"/>
                    </colgroup>
                    <thead>
                        <th style="border-style:solid; border-width: 0px;">
                                <div style="float: left">31</div><div style="float: right">25</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">24</div><div style="float: right">20</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">19</div><div style="float: right">15</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">14</div><div style="float: right">12</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">11</div><div style="float: right">7</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">6</div><div style="float: right">0</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            Instruction
                        </th>
                    </thead>
                    <tbody>
                        <tr  style="float: center"></tr>
                            <td>0111111</td><td>rs2(ix)</td><td>rs1(ptr)</td><td>000</td><td>rd(dst)</td><td>1001001</td><td>dtp</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            The dtp instruction may trigger the following exceptions for the given events (xtval content):
            <ul>
                <li><em>IncompatibleTypeException</em>: rs1 or rs2 contains a pointer, not a value (rs1 or rs2 with rs1 being prioritized)</li>
            </ul>
            <h4><a name="btd">btd-Instruction</a></h4>
            The btd "base to data" instruction allows for reading out a pointers raw pointer value. This value is written into rd for the pointer given in rs1.
            <div style="margin-top: 5%; margin-bottom: 3%;">
                <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                    <colgroup>
                        <col width="20%"/>
                        <col width="13%"/>
                        <col width="14%"/>
                        <col width="8%"/>
                        <col width="14%"/>
                        <col width="20%"/>
                    </colgroup>
                    <thead>
                        <th style="border-style:solid; border-width: 0px;">
                                <div style="float: left">31</div><div style="float: right">25</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">24</div><div style="float: right">20</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">19</div><div style="float: right">15</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">14</div><div style="float: right">12</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">11</div><div style="float: right">7</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">6</div><div style="float: right">0</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            Instruction
                        </th>
                    </thead>
                    <tbody>
                        <tr  style="float: center"></tr>
                            <td>1101111</td><td>00000</td><td>rs1(ptr)</td><td>000</td><td>rd(dst)</td><td>1001001</td><td>btd</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            The btd instruction may trigger the following exceptions for the given events (xtval content):
            <ul>
                <li><em>IncompatibleTypeException</em>: rs1 contains a value, not a pointer (rs1)</li>
            </ul>
            <h4><a name="itd">itd-Instruction</a></h4>
            The itd "index to data" instruction allows for reading out a pointers raw pointer index. This value is written into rd for the pointer given in rs1.
            <div style="margin-top: 5%; margin-bottom: 3%;">
                <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                    <colgroup>
                        <col width="20%"/>
                        <col width="13%"/>
                        <col width="14%"/>
                        <col width="8%"/>
                        <col width="14%"/>
                        <col width="20%"/>
                    </colgroup>
                    <thead>
                        <th style="border-style:solid; border-width: 0px;">
                                <div style="float: left">31</div><div style="float: right">25</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">24</div><div style="float: right">20</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">19</div><div style="float: right">15</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">14</div><div style="float: right">12</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">11</div><div style="float: right">7</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">6</div><div style="float: right">0</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            Instruction
                        </th>
                    </thead>
                    <tbody>
                        <tr  style="float: center"></tr>
                            <td>1011111</td><td>00000</td><td>rs1(ptr)</td><td>000</td><td>rd(dst)</td><td>1001001</td><td>itd</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            The itd instruction may trigger the following exceptions for the given events (xtval content):
            <ul>
                <li><em>IncompatibleTypeException</em>: rs1 contains a value, not a pointer (rs1)</li>
            </ul>
        <h3><a name="lw_x">Raw Memory Access: lw.x/sw.x</a></h3>
            Since the I' ISA abstracts the memory access on ISA level from the actual memory access the hardware performs, it is not guaranteed that a store or load instruction accesses the given memory location or stores the given register data in unmodified form. 
            <h4><a name="lw_x">lw.x-Instruction</a></h4>
            This instruction enables the software to force the hardware to load a word from a given access given by rs1. This address may either be a pointer as well as an address value. 
            After the execution of this instruction, the register selected by rd contains the value of the memory at address rs1.
            <div style="margin-top: 5%; margin-bottom: 3%;">
                <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                    <colgroup>
                        <col width="20%"/>
                        <col width="13%"/>
                        <col width="14%"/>
                        <col width="8%"/>
                        <col width="14%"/>
                        <col width="20%"/>
                    </colgroup>
                    <thead>
                        <th style="border-style:solid; border-width: 0px;">
                                <div style="float: left">31</div><div style="float: right">25</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">24</div><div style="float: right">20</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">19</div><div style="float: right">15</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">14</div><div style="float: right">12</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">11</div><div style="float: right">7</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">6</div><div style="float: right">0</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            Instruction
                        </th>
                    </thead>
                    <tbody>
                        <tr  style="float: center"></tr>
                            <td>1110111</td><td>00000</td><td>rs1(src)</td><td>000</td><td>rd(dst)</td><td>1001001</td><td>lw.x</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <h4><a name="sw_x">sw.x-Instruction</a></h4>
            This instruction enables the software to force the hardware to write a word to a given access given by rs1. This address may either be a pointer as well as an address value. 
            The register rs2 which provides the store data has to contain a value. Please note that although the theoretical order of the registers is sw.x rs1, rs2, the value to be stored comes first in assembly files. 
            This makes the argument order of sw.x analogous to the regular memory access instructions to avoid confusion regarding this order.
            <div style="margin-top: 5%; margin-bottom: 3%;">
                <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center; width: 80%; align: center; margin: auto;">
                    <colgroup>
                        <col width="20%"/>
                        <col width="13%"/>
                        <col width="14%"/>
                        <col width="8%"/>
                        <col width="14%"/>
                        <col width="20%"/>
                    </colgroup>
                    <thead>
                        <th style="border-style:solid; border-width: 0px;">
                                <div style="float: left">31</div><div style="float: right">25</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">24</div><div style="float: right">20</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">19</div><div style="float: right">15</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">14</div><div style="float: right">12</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">11</div><div style="float: right">7</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            <div style="float: left">6</div><div style="float: right">0</div>
                        </th>
                        <th style="border-style:solid; border-width: 0px;">
                            Instruction
                        </th>
                    </thead>
                    <tbody>
                        <tr  style="float: center"></tr>
                            <td>1111011</td><td>rs2(sd)</td><td>rs1(ptr)</td><td>000</td><td>00000</td><td>0001011</td><td>sw.x</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            The sw.x instruction may trigger the following exceptions for the given events (xtval content):
            <ul>
                <li><em>IncompatibleTypeException</em>: rs2 contains a pointer, not a value (rs2)</li>
            </ul>
    </section>
    
    <h1><a id="frames">The not so stacked frames</a></h1>
        <p>In order to protect the local data as well as control flow data of a function, RISC-ViO alters the concept of what is called a stack in conventional architectures.
            To protect the stand-ins for this stack, the so-called frame objects or frames, from malicious or accidental modification by foreign functions, RISC-ViO introduces additional protection mechanisms for these frame objects.</p>
        <!--@Leyla: Linked Frames-->
                <p>
        Apart from objects for regular data storage the I' ISA also manages the stack as a series of objects. This partition of the stack in a single frame per function allows for further security mechanisms but also requires cooperation by the program.
        Most notably, the stack is not grown by arithmetically modifying the stack pointer. Instead, the program has to manually allocate a new frame object. Once this frame object has been allocated, accesses to inside this object behave just the way the stack frame in RISC-V behaves.<br>
        Due to the stack pointer register now containing a pointer, I' is able to protect older frame objects from accesses by arithmetical modification of sp.
        The implications for the passing of function arguments between functions are outlined in the <a href="#chap_calling_convention">calling convention</a> chapter.
        </p>
        <h2><a id="are_obj">Structure</a></h2>
            <p>
                Frame objects are based on regular objects but differ in the accesses which are allowed on them. 
                Frame objects are never data only which means the data only bit in their header is cleared while the frame bit is set. 
                To protect both the stack pointer <em>sp</em> as well as the return index <em>ra</em>, in frame objects special slots are reserved. For the 'stack' pointer <em>sp</em>, the pointer to the previous frame object, the first slot of XLEN size at byte index zero is reserved. 
                This is immediately followed by the <em>ra</em> slot which is also XLEN wide. For XLEN=32, this slot resides at byte address 4.
                In the user mode, these slots of a frame object are only allowed to be used to store or load their respective register. Any other operation on these slots will lead to a <em>ForbiddenDstException</em> or <em>ForbiddenSrcException</em>.
                Note that it is not only prohibited to store any other register than <em>sp</em> and <em>ra</em> in those slots, but also to store these registers anywhere else when in not in a privileged mode. The same restriction also applies when loading these registers.
                This restriction is also enforced using <em>ForbiddenDstException</em> and <em>ForbiddenSrcException</em>.
                <figure style="display:flex; margin-bottom: 0.5rem">
                    <div style="flex: 30%; margin-bottom: 0.5rem">
                        <figcaption>A Frame Object for XLEN=32</figcaption>
                        <img src="svg/objektbaukasten/frame_object.svg" id="frame_object_svg" style="width: 35%;margin-bottom: 0.5rem">
                    </div>
                </figure>
                All other slots are general purpose and access to them is not restricted in any way.
            </p>
        <h2><a id="chap_calling_convention">Calling Convention</a></h2>
            <p>As described in the introduction to this chapter, RISC-ViO denies foreign access to frame objects. As a consequence, the calling convention has be modified slightly from the convention used by RISC-V.
                Namely, it is not possible to spill function arguments from registers onto the stack of the receiving function. Instead, the following scheme is employed: 
                Just as is the case for conventional RISC-V, the arguments are stored in the registers <em>a0</em> to <em>a7</em> given that there are no more than eight XLEN arguments or as many arguments as will fit in those registers.
                Instead of pushing the additional arguments that will not fit in the argument registers on the stack, a spill object of corresponding size has to be allocated. A pointer to this spill object is placed in <em>a7</em> and the remaining arguments are stored in this object.
            </p>
        <section>
            <h2><a id="frame_ownership">Frame Ownership</a></h2>
                <p>
                    To achieve protection of frames from foreign accesses RISC-ViO uses so-called colour tags for both the <em>sp</em> and the <em>ra</em> register.
                    By updating those colours at critical points such as function entries/exits and frame allocations, the processor always knows whether the frame pointed to by the
                    sp register is owned by the currently executed function. 
                    This state is called "regular", while the current function not being the owner of the current frame is denoted as the "irregular" state.
                </p>
                <p>For sp as well as for ra, there are two colours: black and white. Those colours are an integral part of those registers and cannot be read or modified separately from their registers.
                    Also, when storing/loading ra or sp using sw/lw, the colour is also stored/retrieved to/from the given memory location.
                    An overview of the transition between those colours is given in Figure 1.
                    On every function entry, signified by a <em>jalr ra, zero, x (call)</em> instruction, the processor flips the colour of ra from white to black or vice versa. The same also happens when a function is exited using <em>jalr zero, ra, 0 (ret)</em>. For sp, this takes place on every frame allocation.
                    Whether the processor is currently in the regular state (light blue), is given by the equality of the colours of ra and sp. 
                    If the colours of sp and ra both were black for example, the processor would be in the regular state.
                </p>
                <p>
                    Any access to the current frame while in irregular state leads to a <em>StateException</em> indicating access to a foreign frame.
                </p>
            <figure>
                <figcaption>Colour transitions</figcaption>
                <div style="width: 100%; display: flex; justify-content: center;">
                    <div style="width: 80%; display: flex; justify-content: space-around; flex-direction: row;  flex-wrap: wrap;">
                        <div style="margin: 0px auto" >
                            <img src="svg/vio_stack_colors_transitions.drawio.svg" id="svg2" style="width: 20rem; margin: 0px auto;">
                        </div>
                    </div>
                </div>
            </figure>
                <p>
                    Figure 2 provides two sample program flows for which the colour and therefore state transitions are shown. 
                    Figure 2a) shows the behaviour of the colour mechanism during the execution of a correct stream of instructions while figure 2b) highlights how this mechanism catches bad program behaviour. 
                    In 2b) the colour mechanism spots function b trying to access function a's frame, which leads to the processor raising a <em>StateException</em>.
                </p>
            <figure>
                <figcaption>State transitions for examplary instruction streams</figcaption>
                <div style="display: flex; margin-top: 14pt; margin-bottom: 28pt;">
                    <img src="svg/vio_stack_colors.drawio.svg" id="svg1" style="flex: 50%; margin-right: 10pt;">
                    <img src="svg/vio_stack_colors_exception.drawio.svg" id="svg2" style="flex: 50%; margin-left: 10pt; align-self: baseline;">
                </div>
                <div style="display: flex;">
                    <p style="flex: 50%; margin-right: 10pt;">a) Transitions during normal program flow</p>
                    <p style="flex: 50%; margin-left: 10pt;">b) Transitions during abnormal program flow with exception</p>
                </div>
            </figure>
        </section>
    
        <section>   
    <h1><a id="got">Global Offset Table</a></h1>
    <p><i>Der Einsatz von Code-Objekten verbietet Sprünge auf fest definierte Adressen. Auch Speichern und Laden von Daten an festen Adressen ist mit dem Objektansatz unvereinbar.
        In herkömlichen Architekturen kommen zum Auflösen von (zur Compilezeit) unbekannten Adressen "Global Offset Tables" (GOT) zum Einsatz. Möchte ein Programm auf bestimmte Runtime-Funktionen
        wie z.B. printf() zugreifen, kompilieren gcc und clang keinen Sprung zu einer absoluten Adresse in den Programmablauf, sondern einen Sprung in die für dieses Programm individulle GOT.
        Die GOT wird dann wenn das Programm geladen wird vom Betriebssystem gefüllt, sodass diese den Sprung an die richtige Stelle in der Runtime weiterleitet. Der "Umweg" über die GOT
        dient vor allem Sicherheitstechnischen Aspekten. So kann ein Betriebssystem den Zugriff auf bestimmte Runtime Funktionen verwehren, indem es sich beim Laden des Programmes entscheidet,
        die Adresse der Funktion nicht in die GOT einzutragen. Außerdem kann das Betriebssystem die echten Adressen der Runtime-Funktionen vor dem Nutzerprogramm verstecken, indem es in die 
        GOT nicht die Endadresse sondern auf eine weitere, für das Nutzerprogramm nicht lesbare aber ausführbare, Sprungtabelle verweist.
        Neben den Sicherheitsaspekten bieten GOTs auch noch die Möglichkeit des "Lazy Linkings". Die GOT Einträge werden beim Laden des Programmes nicht auf die tatsächlichen Zieladressen,
        sondern auf die Adresse des Dynamischen Linkers gesetzt. Soll nun das erste Mal ein Bibliotheksaufruf ausgeführt werden, wird in wirklichkeit zuerst der Linker angesprungen, der
        die Adresse des Sprungziels ermittelt. Diese ersetzt dann den Eintrag in der GOT die den Linker aufgerufen hat, so dass folgende Sprünge nicht noch einmal den Linker ansprechen müssen.
    </i></p>
    <h2><a id="gp">Global Pointer</a></h2>
    <p><i>In der herkömlichen RISC-V ABI wird die Adresse der GOT über die Distanz zum jal[r] Befehl angegeben. Dieser Ansatz ist in ViO nicht nutzbar, da ein Objekt nicht gleichzeitig
            lesbar und ausführbar sein kann. Zu diesem Zweck wird eine Art "companion"-Objekt eingeführt, dass alle Adressen, auf die ein Executable zu seiner Ausführung zugreifen möchte, führt.
            Anders als bei herkömlichen GOTs werden in diesen Objekten keine Offsets, sondern reine Zeiger gespeichert. Auch ausführbarer Code für Bibliotheksaufrufe befindet sich nicht in einer solchen GOT. 
            {gramm: Auf} Die "companion"-GOT kann in RISC-ViO immer über das Register <em>x3</em> (<em>gp</em>) zugegriffen werden. {In order for <em>gp</em> to always contain the pointer to the GOT of the current object during regular program execution, RISC-ViO mandates that the <em>jalr</em> instruction has to update this register on every jump another executable object. On changes of the currently executed object due to exceptions, interrupts as well as <em>sret</em> and <em>mret</em> instructions, it is the duty of the system management software to update <em>gp</em>.}Es ist Aufgabe der Hardware oder des Betriebssystems dafür zu sorgen, dass das gp-Register immer
            auf das dem Executable zugehörigen GOT-Objekt verweist. 
        </i></p>
    <h2><a id="static">Making Library Calls</a></h2>
        <p><i>Um nun einen Bibliotheksaufruf auszuführen wird zuerst die Adresse der Bibliotheksfunktion aus der GOT mittels eines normalen Ladebefehls geladen und dann mit einem jalr and diese Adresse gesprungen.
            Um dem Linker mitzuteilen, dass für dieses Sprungziel ein GOT-Eintrag angelegt werden soll, wurde ein neuer Assembler Modifier eingeführt: %got_off(symbol). Dieser Modifier wird vom Linker ersetzt durch den Offset
            in der GOT der Executable an dem das symbol zu finden ist. Zu diesem Zweck wurde auch ein neuer Relocation/Dynsym-Typ eingeführt, um in ELF-Files zu markieren dass an einer bestimmten Stelle der load-offset noch
            ersetzt werden muss, mit dem endgültigen Offset der Adresse in der GOT, ähnlich wie es auch bei den Assembler Modifiern %hi, %lo, usw. gehandhabt wird.
            Ein<br>call symbol<br>wird also nun ersetzt durch eine<br>lw t1, %got_off(symbol)(gp)<br>jalr ra, 0(t1)<br>Abfolge.
        </i></p>
    <h2><a id="static">Accessing static objects</a></h2>
        <p><i>Nach dem selben Prinzip werden auch Zugriffe auf statische Objekte gehandhabt. Über den %got_off modifier wird der Linker angewiesen, den Zeiger auf das Objekt in der GOT vorzuhalten und den Zugriff
            auf das Objekt zur Load-Time aufzulösen. Die statischen Objekte werden auch schon in herkömmlichen ELF-Files markiert, sodass der Lader in ViO mit einem normalen ALC Befehl das statische Objekt anlegen,
            evtl. befüllen und den Zeiger auf dieses Objekt in der GOT hinterlegen kann.
        </i></p>
    </section>
    
    <section>
    <h1><a id="exceptions">Exceptions</a></h1>
        <h2><a id="gen">Enforcing correct program behaviour</a></h2>
            <p>
                To enforce the pointer based memory access scheme, the processor will raise a <em>IncompatibleTypeException</em> when a program tries to use an address value to access memory. 
                Since the object length is known on ISA level, the processor is able to raise a <em>IndexOutBoundsException</em> when an out of bound load or store instruction is executed.
                In case of such an exception, <em>xtval</em> will contain the base pointer as well as the index which was beyond the object bounds.
                The processor is also able to detect whether the destination object is compatible with the current access type. 
                In consequence, <em>LoadAccessFault</em>, <em>StoreAccessFault</em> or <em>IncompatibleTypeException</em> will be raised when the corresponding flag is not set as per <a href="#objs_ords">ordinary objects</a>. 
                <em>LoadAccessFault</em>s are triggered when the read-flag is cleared while <em>StoreAccessFault</em> is raised in case of a store access to a object with cleared write flag.
                Trying to store pointers to a data only object marked by a set data-only-flag will also lead to a <em>IncompatibleTypeException</em>. 
                The same exception is triggered when trying to jump to a regular object using <em>jalr</em>.
            </p>
            <p>
                Trying to access the register <em>gp</em> for anything other than as a access pointer in a memory instruction will lead to a <em>GPAccessException</em>.
            </p>
            <p>
                To inform the software that a access to a regular or executable object would lie outside its bounds, a <em>JumpIndexOutBoundsException</em> is raised in case of an executable object or a <em>IndexOutBoundsException</em> in case of a regular object.
                Should the heap onto which new objects are allocated on reach the end of its capacity, a <em>HeapOverflowException</em> is raised.
            </p>
            <p>
                In the context of frame objects, a total of three exceptions are added to the exception list.
                A <em>StateException</em> catches access to foreign frame objects as described in <a href="#frame_ownership">frame ownership</a>.
                Even when a frame object is owned by the currently executed function, there are still two more exceptions possible: <em>ForbiddenDstException</em> is raised when trying anthing else than <em>ra</em> or <em>gp</em> into their slots.
                <em>ForbiddenSrcException</em> checks for using these slots as specified in case of load accesses.

            </p>
            <p>
                The <em>IncompatibleTypeException</em> is also raised when a pointer is written to a I/O device using its corresponding pointer.
            </p>
        <h2><a id="gen">Exceptions in conjunction with CSR</a></h2>
            <p>Since RISC-ViO allows both pointers and values to be stored in the registers and also organizes code using objects, some CSR also need to be able to hold pointers.
                This is the case for <em>xtvec</em> and <em>xepc</em> due to code objects and for <em>xtval</em> and <em>xscratch</em> due to pointers in general.
                To access the components of these registers, the <em>csrw</em> instruction may be used in conjunction with the <em>dtp</em>/<em>btd</em>/<em>itd</em> instructions.
                Apart from this slight modification as well as the expansion of available exceptions, exceptions and interrupts behave identical to the way they do in RISC-V.
            </p>
        <h2><a id="priv">Exception masking</a></h2>
            <p>
                The <a href="#t_csr">exception table</a> provides an overview of the exceptions corresponding to the protection schemes introduced by RISC-ViO.
                In order to allow higher privilege modes to gain the access required for system management, some exceptions are suppressed in certain privilege modes.
            </p>
        
    </section>

    <h1><a id="reg_fl">Values and Pointers in the Register File</a></h1>
    <section>
    <p>
        Every RISC-ViO architecture requires a register file which is able to satisfy the requirements given in the <a href="#base_spec">I'</a> chapter.
        Apart from these requirements, RISC-ViO does not specify how a register file of an implementation of this architecture has to look like.
        This leaves room for tailoring the implemented register file to the design constraints at hand. 
    </p>
    <p style="font-size: 9pt;">
        (Please note that in this specification, pointers are written in the form x.y where x is a pointers value (base address + tag) and y is the index of the pointer. To graphically set apart pointers from values, pointers are drawn in various shades of pink and purple.
        Values are not denoted in any special way in text form but drawn in light blue.)
    </p>
    </section>
    <h2><a id="fields">Fields</a></h2>
    <section>
        <p>The subarchitecture implementation offered here is meant only as an example implementation and is focused on higher performance while requiring more hardware resources. The register sections required by the RISC-ViO specification are denoted with 'ISA' while sections introduced by this particular implementation are denoted with 'IMP'. In this implementation, the 'IMP' sections are exclusively made up of object header metadata drawn in green.  </p>
        <figure style="display:flex; margin-bottom: 0.5rem">
            <div style="flex: 30%; margin-bottom: 0.5rem">
                <figcaption>An example implementation of a RISC-ViO register file</figcaption>
                <img src="svg/register_file.drawio.svg" id="register_file_svg" style="width: 100%;margin-bottom: 0.5rem">
            </div>
        </figure>
    </section>
    <h2><a id="coloring">Colouring</a></h2>
    <section>
        <p>As described in the <a href="#frames">frames</a> chapter and as present in the requirements list in <a href="#base_spec">I'</a>, RISC-ViO calls for the ability to hold colour information for both the <em>ra</em> as well as the <em>sp</em> register. 
            The implementation presented here is able to satisfy this requirement using the fields as shown in the last section only. In this implementation, the colour 'black' is encoded as a cleared bit ('0') while 'white' corresponds to a bit which is set ('1'). 
            Since the smallest possible instruction size specified by RISC-V is 16 bits or two bytes, the lowest bit of the index of <em>ra</em> always has to be zero.
            This is why it is possible to encode the current colour of <em>ra</em> in this bit. For <em>sp</em>, the same is not true however since its index may be set to any value.
            The colour of <em>sp</em> is instead stored in the current frames header copy in the register file. More specifically, the colour-bit in this header is used for storing <em>sp</em>'s colour.
        </p>
    </section>
    <h2><a id="flgs_tgs">Flags and Tags</a></h2>
    <section>
        <p>In order to distinguish pointers from values, the provided implementation uses a tag bit for all registers which may hold both values or pointers. Values are tagged as '0' while pointers are identified by a '1' bit.
            Since on ISA level, RISC-ViO only distinguishes between regular an I/O pointers, only a single bit in the register file is required to keep those pointer types apart.
            This bit is interpreted as part of the pointer and is added to the right of the pointer base address or I/O device number for I/O pointers.
        </p>
    </section>


    <h1><a id="hard_obj">Objects in Memory</a></h1>
    <section style="display:flex">
        <div class="screen2_print1">
            <h2 style="text-align: center;"><a id="headers">Headers</a></h2>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                Headers mark the beginning of every Object. They hold all information about the object necessary to ensure proper handling of itself. Headers are always 16-Byte aligned.</p>
            <figure>
                <img src="svg/objektbaukasten/header.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>Header Bitmap on 32-Bit Architectures</figcaption>
            </figure>
            <table summary="Bit Values of Object Headers" style="width: 80%; margin-left: 10%; margin-right: 10%;">
                <thead>
                    <tr>
                        <th>Bits</th>
                        <th>Sym.</th>
                        <th>Details</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>31:30</td>
                        <td>gc</td>
                        <td>Bits reserved for garbage collection</td>
                    </tr>
                    <tr>
                        <td>29</td>
                        <td>r</td>
                        <td>Readable</td>
                    </tr>
                    <tr>
                        <td>28</td>
                        <td>w</td>
                        <td>Writable</td>
                    </tr>
                    <tr>
                        <td>27</td>
                        <td>d</td>
                        <td>Data-Only</td>
                    </tr>
                    <tr>
                        <td>26</td>
                        <td>s</td>
                        <td>Sanctuary</td>
                    </tr>
                    <tr>
                        <td><i>25:7</i></td>
                        <td><i>-</i></td>
                        <td><i>don't care</i></td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td>c</td>
                        <td>Color of Frame Objects.<br>See <a href="#frames">Frames Chapter</a></td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>f</td>
                        <td>Frame Object</td>
                    </tr>
                    <tr>
                        <td>4:0</td>
                        <td>-</td>
                        <td>Header Identifier</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>31:3</td>
                        <td>λ</td>
                        <td>Length of Object<br>(only bits (63|31):3)</td>
                    </tr>
                    <tr>
                        <td><i>1</i></td>
                        <td><i>-</i></td>
                        <td><i>don't care</i></td>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td>-</td>
                        <td>Data Identifier</td>
                    </tr>
                </tbody>
            </table>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                <i>On a 64-Bit Architecture the upper bits of the header bitmap are shifted upwards to 64-Bit boundaries.</i></p>

            <h2 style="text-align: center;"><a id="elements">Elements</a></h2>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                Elements of Objects are tagged by the lowest Bit(s) in a Chunk of Memory.
                On a 32-Bit Architecture this Chunk is 32 bits wide, on 64-Bit Architectures 64 bits.</p>
            <figure style="margin-top: 0; margin-bottom: 1em">
                <img src="svg/objektbaukasten/data.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>Word, Half and Byte locations in an ordinary object</figcaption>
            </figure>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                Data in Ordinary Objects is identified by the trailing <em>0</em>-Bit. If a Store is attempted, which would make the two uppermost bits of a chunk unequal (e.g. <em>bit-31 &ne; bit-30</em> on a 32-Bit Architecture)
                then the Data is stored to the current sanctuary Object instead and the corresponding displacement pointer will be stored to the address the original store was attempted to.</p>
            <figure style="margin-top: 0; margin-bottom: 1em">
                <img src="svg/objektbaukasten/disp_prim_ptr.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>Pointer to displaced data</figcaption>
            </figure>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                These Pointers are identified by trailing <em>01</em>-Bits.</p>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%; margin-top: 2em">
                Pointers to Objects are identified by trailing <em>0111</em>-Bits. They can be generated by allocation instructions and point to the head of ordinary, data-only and executable objects.</p>
            <figure style="margin-top: 0; margin-bottom: 1em">
                <img src="svg/objektbaukasten/pointer.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>Pointer to an Object</figcaption>
            </figure>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                If a store is attempted on a pointer that was modified by arithmetic instructions so that its index is unequal to zero, the pointer will be displaced into the current sanctuary object and only the displacement pointer
                is stored to the original address the store was attemped to.</p>
            <figure style="margin-top: 0; margin-bottom: 1em">
                <img src="svg/objektbaukasten/disp_ptr_ptr.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>Pointer to a displaced Pointer</figcaption>
            </figure>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                These Pointers are identified by trailing <em>011</em>-Bits.</p>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%; margin-top: 2em">
                Pointers to I/O-Capabilities are identified by the trailing <em>01111</em>-Bits. They hold a device-id which identify what I/O-Device is referenced.</p>
            <figure style="margin-top: 0; margin-bottom: 1em">
                <img src="svg/objektbaukasten/io_ptr.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>I/O-Pointer</figcaption>
            </figure>
        </div>
        <div class="screen2_print1">
            <h2 style="text-align: center;"><a id="ords">Ordinaries</a></h2>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                Ordinary Objects always start with a Header and can hold every element type defined.</p>
            <figure style="margin-top: 0;">
                <img src="svg/objektbaukasten/ordinary_object.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>Ordinary Object and its possible Elements</figcaption>
            </figure>
            
            <h2 style="text-align: center;"><a id="data-onlies">Data-Only Objects</a></h2>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                Data-Only Objects are identified by the data-only Bit in the Header. Data inside of these Objects is not tagged, so they make use of the whole 64|32 Bit per Element.
                Pointers are forbidden inside data-only Objects.</p>
            <figure style="margin-top: 0;">
                <img src="svg/objektbaukasten/data_only_object.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>Data-Only Object</figcaption>
            </figure>

            <h2 style="text-align: center;"><a id="execs">Executables</a></h2>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                Executables have only the data-only bit set in their header. This identifies them as a executable.<br>
                As part of their Header, Executables have the pointer to their companion GOT stored at the third (double-)word of the object. The start of Code is then referred as index 0 of the objuect.
                It is stored in the same fashion as in data-only so they can harvest the full 64|32 bit of a Element.</p>
            <figure style="margin-top: 0;">
                <img src="svg/objektbaukasten/executable_object.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>Executable Object</figcaption>
            </figure>

            <h2 style="text-align: center;"><a id="sancts">Sanctuaries</a></h2>
            <p style="width: 80%; margin-left: 10%; margin-right: 10%;">
                Sanctuaries only have the Sanctuary Bit set in their header. They are used as memory space for displaced primitives and displaced pointers and cannot be referenced by ordinary pointers.<br>
                Displaced Pointers take two Element Slots, one for the base pointer and one for the index, thus are always aligned to 2-Element boundaries.
                The base pointer is stored as a ordinary pointer and the index as data-only primitive.<br>
                Displaced Primitives only take one Element Slot beeing the (Double-)Word that was displaced. These Types can be stored at any Element position inside the Sanctuary.</p>
            <figure style="margin-top: 0;">
                <img src="svg/objektbaukasten/data_only_object.svg" style="width: 60%; margin-left: 20%; margin-right: 20%;">
                <figcaption>Sanctuary Object</figcaption>
            </figure>
        </div>
    </section>

    <h1><a id="ptr_addr">Pointer and Address generation</a></h1>
        <p>The provided implementation example of the RISC-ViO architecture by using the object structures outline above implies new requirements for a processor pipeline supporting this implementation.
            In the next sections, a possible subarchitecture meeting those requirements shall be described. </p>
    <h2><a id="alcs">Allocations</a></h2>
    <section>
        <p>In the presented implementation, all members of the alc instruction family place both regular data objects as well as frames objects on the heap. 
            There the objects lie in allocation order until a garbage collection cycle occurs. The CSR <em>malc</em> is used to keep track of the heap fill level and heap limit. <em>malc.ix</em> keeps track of to the newest objects start address while <em>malc.ptr</em> contains the lower limit of the heap in form of an address. 
            In the process of such a cycle, objects may be moved or overwritten in case of not being required anymore.
        </p>
        <p>
            The allocation process starts by calculating the address of the address of the new object header. 
            This is given by rounding down the value given by the expression
        </p>
        <div class="equation">
            <math>
                <mtable>
                    <mtr>
                        <mtd>
                            <mi>malc.ix</mi>
                            <mo>-</mo>
                            <mo>(</mo>
                            <mi>8</mi>
                            <mo>+</mo>
                            <mi>size</mi>
                            <mo>)</mo>
                        </mtd>
                    </mtr>
                </mtable>
            </math>
        </div>
        <p>
            down to next number divisible by 16. If this value is larger than malc.ptr the new object fits inside the heap and malc.ix is updated to this value.
            In this case, a pointer tag is added to the newly calculated address and the resulting pointer value is written to the target register.
            The initial index is set to zero. 
        </p>
        <p>
            To commit the header of this new object to memory, the so-called attribute cache is used. 
            This cache is located in the attribute stage located behind the memory stage and is mainly used to both retrieve and load object attributes.
            In case of values with bit 31 set or pointers with non-zero index this cache is also used to both store and retrieve these types of data to and from memory.
        </p>
        <figure>
            <figcaption>Heap limits and growth.</figcaption>
            <div style="display: flex; margin-top: 14pt; margin-bottom: 28pt; height: 25rem">
                <img src="svg/vio_heap_growth.drawio.svg" id="svg1" style="flex: 50%; margin-right: 10pt;">
                <img src="svg/vio_heap_overflow.drawio.svg" id="svg1" style="flex: 50%; margin-right: 10pt;">
            </div>
            <div style="display: flex;">
                <p style="flex: 50%; ">a) Regular heap growth </p>
                <p style="flex: 50%; ">b) Heap overflow</p>
            </div>
        </figure>
        <p>
            The given implementation uses sanctuary objects to cope with the requirement to distinguish between pointers and values in memory.
            Any time a value with the highest bit set or a pointer with a non-zero index is stored, a slot of corresponding size and alignment in the current sanctuary object is used.
            For values this alignment and size is 4 bytes while for pointers with index it is 8 bytes. 
            The sample implementation has the sanctuary index point to the last used slot in the sanctuary object and decrements this index on every sanctuary slot allocation.
        </p>
        <p>
            When the current sanctuary object is full, which is signified by the sanctuary index being zero, while a new sanctuary slot is required, a new sanctuary object is allocated.
            For this, the current allocation address is decremented according to the implementation-dependant sanctuary object size and the sanctuary object address is set to this value.
            Also, the sanctuary slot index is set to highest possible value for the new sanctuary object to be once again be filled from the top to the bottom.
            In order to ensure the garbage collector being aware of this object, the attribute cache in the attribute stage also writes a header stub to the address at which the sanctuary object lies.
            In the flags field of this header, the sanctuary bit marks this object as a sanctuary object.
        </p>
    </section>
    <h2><a id="load_store">Loading and Storing a Pointer</a></h2>
    <section>
        <p>As the subarchitectural implementation requires some flag bit from the object header as well as its length or lambda field, those fields also have to be retrieved from memory when loading a pointer. 
            For this, the example subarchitectural implementation uses an additional pipeline stage called the attribute stage which is located behind the memory stage in the processor pipeline.<br>
            The <a href="#t_instr_in_pipe">instruction behaviuor table</a> shows how this stage interacts with the stages that come before it, this section looks at this interaction in further detail.
            After the memory stage has loaded a pointer, the attribute stage then loads the header being pointed to by the pointer base address. This header along with the actual pointer value is then handed over to the write-back stage which writes those fields into the register file.
            In the given subarchitectural implementation, the attribute stage is used to accomplish additional tasks like loading full XLEN wide data or a pointer with non-zero index from an object. 
            For the task of loading full XLEN wide data, it is the task of the attribute stage to load the actual data from memory instead of the memory stage. This is necessary since the memory stage has to determine where this data is located in memory first by loading the according displacement pointer.
            For pointers with a non-zero index, the attribute stage also has to become active. Since requiring both the loading of a pointers index as well as the header of the object pointed to, this operation takes two clock cycles however and therefore necessitates stalling the remaining pipeline until both operations have been completed.
            In this situation, the attributes stage will load the pointer index before loading the object header and combining the loaded fields with the pointer value loaded by the memory stage and passing the combined register file entry to the writeback stage.
        </p>
        <p>
            The process of storing register contents is analogous to the process of loading values as well as pointers regarding the fundamental tasks accomplished by the memory and attribute stages. The only difference other than those stages storing instead of loading is that the attribute stage might need to allocate a new 'Sanctuary object' to store XLEN wide values or pointers with non-zero index into.
            This task is completed by a special subunit, which avoids the attribute stage having to stall the remaining pipeline when storing a XLEN value or pointer with non-zero index while also needing a new Sanctuary Object to be allocated.
        </p>
    </section>

    <h2><a id="bounds">Bounds and Flag Checks</a></h2>
    <section>
        <p>As the outlined subarchitecture keeps the length of the corresponding object for each pointer in the register file, it is possible to check for an out of bound access as soon as the actual access index is available. 
            This can be the case as early as in the execute stage, which allows for early raising of <em>IndexOutBoundsException</em>s. 
            Since an objects flags which signify it as being readable, writeable and data only are also available as soon as the pointer to this object is available in the processor, the conditions for <em>LoadAccessFault</em> and <em>StoreAccessFault</em> exceptions can also be tested for just as early.</p>
    </section>

    <h1><a id="tables">Tables</a></h1>
    
    
    <section>
    <h2><a id="t_inst">Instructions (zhm extension)</a></h2>
        <table cellspacing="0" cellpadding="0" class="table-ta1" style="border: 0; text-align:center">
            <colgroup>
                <col width="20%"/>
                <col width="13%"/>
                <col width="14%"/>
                <col width="8%"/>
                <col width="14%"/>
                <col width="20%"/>
            </colgroup>
            <thead>
                <th style="border-style:solid; border-width: 0px;">
                        <div style="float: left">31</div><div style="float: right">25</div>
                </th>
                <th style="border-style:solid; border-width: 0px;">
                    <div style="float: left">24</div><div style="float: right">20</div>
                </th>
                <th style="border-style:solid; border-width: 0px;">
                    <div style="float: left">19</div><div style="float: right">15</div>
                </th>
                <th style="border-style:solid; border-width: 0px;">
                    <div style="float: left">14</div><div style="float: right">12</div>
                </th>
                <th style="border-style:solid; border-width: 0px;">
                    <div style="float: left">11</div><div style="float: right">7</div>
                </th>
                <th style="border-style:solid; border-width: 0px;">
                    <div style="float: left">6</div><div style="float: right">0</div>
                </th>
                <th style="border-style:solid; border-width: 0px;">
                    Instruction
                </th>
            </thead>
            <tbody>
                <tr  style="float: center">
                    <td>0000000</td><td>0000</td><td>rs1(src)</td><td>000</td><td>rd(dst)</td><td>0001011</td><td>alc</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td colspan="2">imm[13:2]</td><td>00010</td><td>010</td><td>rd(dst)</td><td>0001011</td><td>alci</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td>0000000</td><td>0000</td><td>rs1(src)</td><td>001</td><td>rd(dst)</td><td>0001011</td><td>alcd</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td colspan="2">imm[13:2]</td><td>00010</td><td>011</td><td>rd(dst)</td><td>0001011</td><td>alcid</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td>0000000</td><td>0000</td><td>rs1(src)</td><td>100</td><td>rd(dst)</td><td>0001011</td><td>qsz</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td>0111111</td><td>rs2(ix)</td><td>rs1(ptr)</td><td>000</td><td>rd(dst)</td><td>1001001</td><td>dtp</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td>1101111</td><td>00000</td><td>rs1(ptr)</td><td>000</td><td>rd(dst)</td><td>1001001</td><td>btd</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td>1011111</td><td>00000</td><td>rs1(ptr)</td><td>000</td><td>rd(dst)</td><td>1001001</td><td>itd</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td>1110111</td><td>00000</td><td>rs1(src)</td><td>000</td><td>rd(dst)</td><td>1001001</td><td>lw.x</td>
                </tr>
                <tr  style="float: center"></tr>
                    <td>1111011</td><td>rs2(sd)</td><td>rs1(ptr)</td><td>000</td><td>00000</td><td>0001011</td><td>sw.x</td>
                </tr>
            </tbody>
        </table>
    </section>


    <h2 class="page-break-before"><a id="t_op">Object and Pointer Types</a></h2>
    <section>
        <figure style="display:flex">
            <div style="flex: 50%;">
                <p style="font-size: 16pt; font-style: italic; text-indent:0;">Header</p>
                <img src="svg/objektbaukasten/header.svg" id="header_table_svg" style="width: 60%;">
                <p style="font-size: 16pt; font-style: italic; text-indent:0; margin-top: 1.5rem;">Data</p>
                <img src="svg/objektbaukasten/data.svg" id="header_table_svg" style="width: 60%;">
                <p style="font-size: 16pt; font-style: italic; text-indent:0; margin-top: 1.5rem;">Displacement Pointer (Primitive)</p>
                <img src="svg/objektbaukasten/disp_prim_ptr.svg" id="header_table_svg" style="width: 60%;">
                <p style="font-size: 16pt; font-style: italic; text-indent:0; margin-top: 1.5rem;">Displacement Pointer (Pointer)</p>
                <img src="svg/objektbaukasten/disp_ptr_ptr.svg" id="header_table_svg" style="width: 60%;">
                <p style="font-size: 16pt; font-style: italic; text-indent:0; margin-top: 1.5rem;">Ordinary Pointer</p>
                <img src="svg/objektbaukasten/pointer.svg" id="header_table_svg" style="width: 60%;">
                <p style="font-size: 16pt; font-style: italic; text-indent:0; margin-top: 1.5rem;">I/O-Pointer</p>
                <img src="svg/objektbaukasten/io_ptr.svg" id="header_table_svg" style="width: 60%;">
            </div>
            <div style="flex: 50%;">
                <p style="font-size: 16pt; font-style: italic; text-indent:0;">Ordinary Object</p>
                <img src="svg/objektbaukasten/ordinary_object.svg" id="header_table_svg" style="width: 60%;">
                <p style="font-size: 16pt; font-style: italic; text-indent:0; margin-top: 1.5rem;">Executable Object</p>
                <img src="svg/objektbaukasten/executable_object.svg" id="header_table_svg" style="width: 60%;">
                <p style="font-size: 16pt; font-style: italic; text-indent:0; margin-top: 1.5rem;">Data-Only Object</p>
                <img src="svg/objektbaukasten/data_only_object.svg" id="header_table_svg" style="width: 60%;">
            </div>
        </figure>
    </section>
    <h2><a id="t_exc">Exceptions</a></h2>
    <section>
        <table summary="Exceptions and their numbers for privilege modes" style="margin-bottom: 0;">
            <thead>
            <tr>
                <th rowspan="2">
                    <em>xcause index</em>
                </th>
                <th rowspan="2">
                    <em>Name</em>
                </th>
                <th colspan="3">
                    <em>may be raised in privilege mode</em>
                </th>
            </tr>
            <tr>
                <th><em>user</em></th>
                <th><em>supervisor</em></th>
                <th><em>machine</em></th>
            </tr>
            <tr>
                <th>16</th>
                <th>JumpIndexOutBoundsException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>17</th>
                <th>GPAccessException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>18</th>
                <th>IndexOutBoundsException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>19</th>
                <th>HeapOverflowException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>20</th>
                <th>StateException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>21</th>
                <th>ForbiddenSrcException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>22</th>
                <th>ForbiddenDstException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
            <tr>
                <th>23</th>
                <th>IncompatibleTypeException</th>
                <th style="color: #c6afe9">✔</th>
                <th style="color: #c6afe9">✖</th>
                <th style="color: #c6afe9">✖</th>
            </tr>
        </thead>
        <tbody>

        </tbody>
        </table>
    </section>
    <h2><a id="t_csr">CSRs</a></h2>
    <section>
        <table summary="CSR added by zhm extension" style="margin-bottom: 0;">
            <thead>
            <tr>
                <th rowspan="2">
                    <em>CSR index</em>
                </th>
                <th rowspan="2">
                    <em>Name</em>
                </th>
                <th colspan="2">
                    <em>subfields</em>
                </th>
            </tr>
            <tr>
                <th><em>ptr</em></th>
                <th><em>index</em></th>
            </tr>
            <tr>
                <th>0xBC0</th>
                <th>MALC</th>
                <th>current allocation address</th>
                <th>heap end adress</th>
            </tr>
            <tr>
                <th>0xBC1</th>
                <th>MSAD</th>
                <th>free index in sanctuary object</th>
                <th>address of current sanctuary object</th>
            </tr>
           
        </thead>
        <tbody>

        </tbody>
        </table>
    </section>
    <h2 class="page-break-before"><a id="t_heap">Example of a Heap</a></h2>
    <figure class="page-break-after">
        <img src="svg/pretty_heap.svg" id="heap">
    </figure>

    <h2 class="page-break-before"><a id="t_instr_in_pipe">Instructions in a sample Pipeline</a></h2>
    <p>
        This table shows how a pipeline backend implementing the RISC-ViO architecture may look like.
        For this, the fields of the content to be written to a register is shown in the EXecute, MEmory and the new ATtribute stage.
        Also, for each stage the units which are active in this stage for the given instruction are listed. A result field value of 'pass' means that this pipeline stage will only pass along the value of rd from the prior stage while '~' means that rd is invalid and this instruction will not write anything to the register file.
    </p>
    <section>
        <table border="0" cellspacing="0" cellpadding="0" class="table-ta1" style="text-align:left">
            <colgroup>
                <col width="172"/>
                <col width="40"/>
                <col width="40"/>
                <col width="40"/>
                <col width="50"/>
                <col width="300"/>
                <col width="250"/>
                <col width="200"/>
                <col width="250"/>
                <col width="200"/>
                <col width="200"/>
                <col width="150"/>
                <col width="94"/>
            </colgroup>
            <tr class="row-ro1">
                <td colspan="5" style="text-align:left " ></td>

                
                <td colspan="8" style="text-align:center; " >
                    <p>Fields and Actions by Stages</p>
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " ></td>

                <td colspan="3" style="text-align:center; " >
                    register file indeces
                </td>
                <td style="text-align:left; " ></td>
                
                <td colspan="2" style="text-align:center; " >
                    EX
                </td>
                <td colspan="2" style="text-align:center; " >
                    ME
                </td>
                <td colspan="2" style="text-align:center; " >
                    AT first pass
                </td>
                <td colspan="2" style="text-align:center; " >
                    AT second pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    Instruction
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm
                </td>
                
                <td style="text-align:center; " >
                    Actions
                </td>
                <td style="text-align:center; " >
                    Results
                </td>
                <td style="text-align:center; " >
                    Actions
                </td>
                <td style="text-align:center; " >
                    Results
                </td>
                <td style="text-align:center; " >
                    Actions
                </td>
                <td style="text-align:center; " >
                    Results
                </td>
                <td style="text-align:center; " >
                    Actions
                </td>
                <td style="text-align:center; " >
                    Results
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    lui
                </td>

                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm20
                </td>
                
                <td style="text-align:left; " >
                    ALU: add
                </td>
                <td style="text-align:left; " >
                    rd: (T:d, P:0, I:val, L:0, H:0)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    auipc
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    ALU: add
                </td>
                <td style="text-align:left; " >
                    rd: (T:p, P:pc.ptr, I:val, L:pc.l, H:pc.hdr)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    jal
                </td>

                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm20
                </td>
                
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    rd: (T:p, P:pc.ptr, I:pc.ix, L:pc.l, H:pc.hdr)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    jalr step 1
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    gp
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: load
                </td>
                <td style="text-align:left; " >
                    rd:(T:p, P:val, I:0, H:hdr, L:l)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    jalr step 2
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd<sup>2</sup> 
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    DBU: b_tgt
                </td>
                <td style="text-align:left; " >
                    rd: (T:p, P:pc.ptr, I:pc.ix, L:pc.l, H:pc.hdr)<sup>2</sup>
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    bcc
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    disp
                </td>
                
                <td style="text-align:left; " >
                    ALU: comp DBU: (b_tgt)
                </td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    arithi (any data op)
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    ALU: op=imm12 X rs1
                </td>
                <td style="text-align:left; " >
                    rd: (T:d, P:rs1.P, I:val, L:rs1.L, H:rs1.H)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    arithr (any data op)
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    ALU: op=rs2 X rs1
                </td>
                <td style="text-align:left; " >
                    rd: (T:d, P:val, I:val, L:val, H:val)<sup>1</sup>
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    lb/lbu/lh/lhu
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: lb/lbu/lh/lhu
                </td>
                <td style="text-align:left; " >
                    rd:(T:d, P:0, I:val, H:0, L:0)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    sb/sh (bit 31 = 0)
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: sb/sh
                </td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    sb/sh (bit 31 = 1)
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: sw DU: alc_data
                </td>
                <td style="text-align:left; " >
                    caddr, six (sptr, aaddr)
                </td>
                <td style="text-align:left; " >
                    AC: sw (SA: alloc)
                </td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    lw (value, bit 31 = 0)
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: load
                </td>
                <td style="text-align:left; " >
                    rd:(T:d, P:0, I: val, H:0, L:0)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    lw (value, bit 31 = 1)
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: load
                </td>
                <td style="text-align:left; " >
                    caddr
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    rd: (T:d, P:0, I:val, L:0, H:0)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    lw (pointer, ix = 0)
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: load
                </td>
                <td style="text-align:left; " >
                    rd:(T:p, P:val, I:0, H:hdr, L:l)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    lw (pointer, ix != 0)
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: load
                </td>
                <td style="text-align:left; " >
                    rd:(T:p, P:val)
                </td>
                <td style="text-align:left; " >
                    AC: lw
                </td>
                <td style="text-align:left; " >
                    rd: ix_val
                </td>
                <td style="text-align:left; " >
                    AC: lw
                </td>
                <td style="text-align:left; " >
                    rd: l, hdr
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    sw (value, bit 31 = 0)
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: sw
                </td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    sw (value, bit 31 = 1)
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: sw, DU: alc_sadp
                </td>
                <td style="text-align:left; " >
                    caddr, six (sptr, aaddr)
                </td>
                <td style="text-align:left; " >
                    AC: sw (SA: alloc)
                </td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    sw (pointer, ix = 0)
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: sw
                </td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    sw (pointer, ix != 0)
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: sw DU: alc_sadd
                </td>
                <td style="text-align:left; " >
                    caddr, six (sptr, aaddr)
                </td>
                <td style="text-align:left; " >
                    AC: sw (SA: alloc)
                </td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    alc
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    rd: (T:p, P:val, I:0, L: val, H:val), aaddr,caddr
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " >
                    AC: sw [object header]
                </td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    alci
                </td>

                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    rd: (T:p, P:val, I:0, L: val, H:val), aaddr,caddr
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " >
                    AC: sw [object header]
                </td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    alc.d
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    rd: (T:p, P:val, I:0, L: val, H:val), aaddr,caddr
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " >
                    AC: sw [object header]
                </td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    alci.d
                </td>

                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    imm12
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    rd: (T:p, P:val, I:0, L: val, H:val), aaddr,caddr
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " >
                    AC: sw [object header]
                </td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    qsz
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    PGU: rd
                </td>
                <td style="text-align:left; " >
                    rd: (T:d, P:0, I:val, L:0, H:0)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    dtp
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    rd: (T:p, P:val, I:val), caddr
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " >
                    AC: lw [object header]
                </td>
                <td style="text-align:left; " >
                    rd: (L:val, H:val)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    btd
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    PGU: rd
                </td>
                <td style="text-align:left; " >
                    rd: (T:d, P:0, I:val, L:0, H:0)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    itd
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    PGU: rd
                </td>
                <td style="text-align:left; " >
                    rd: (T:d, P:0, I:val, L:0, H:0)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    lw.x
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    rd
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: load
                </td>
                <td style="text-align:left; " >
                    rd:(T:d, P:0, I:val, H:0, L:0)
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    pass
                </td>
                
            </tr>
            <tr class="row-ro1">
                <td style="text-align:left; " >
                    sw.x
                </td>

                <td style="text-align:left; " >
                    rs1
                </td>
                <td style="text-align:left; " >
                    rs2
                </td>
                <td style="text-align:left; " >
                    zero
                </td>
                <td style="text-align:left; " >
                    none
                </td>
                
                <td style="text-align:left; " >
                    AGU: addr
                </td>
                <td style="text-align:left; " >
                    daddr
                </td>
                <td style="text-align:left; " >
                    DC: sw
                </td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                <td style="text-align:left; " ></td>
                <td style="text-align:left; " >
                    ~
                </td>
                
            </tr>
        </table>
        <p>
            Abbreviations used in the table:
            <table style="text-align:left; border-width: 0;">
            <td style="text-align:left; align:left; border-width: 0;" valign="top">
                <ul style="text-align:left; align:left">
                    <li>daddr: data cache address</li>
                    <li>aaddr: attribute cache address</li>
                    <li>caddr: malc current address</li>
                    <li>six: sanctuary slot index</li>
                    <li>sptr: sanctuary object pointer</li>
                </ul>
            </td>
            <td style="text-align:left; align:left; border-width: 0;" valign="top">
                <ul style="text-align:left; align:left">
                    <li>T: tag (d=data, p=pointer)</li>
                    <li>P: pointer value</li>
                    <li>I: pointer index or data value</li>
                    <li>L: object length</li>
                    <li>H: object header</li>
                </ul>
            </td>
            <td style="text-align:left; align:left; border-width: 0;" valign="top">
                <ul style="text-align:left; align:left">
                    <li>DC: data cache</li>
                    <li>AC: attribute cache</li>
                    <li>AGU: address generation unit</li>
                    <li>ALU: arithmetic logc unit</li>
                    <li>DBU: dynamic branch unit</li>
                    <li>DU: displacement unit (manages displacement to sanctuary objects)</li>
                    <li>SA: sanctuary allocator</li>
                </ul>
            </td>
            </table>
            *1: The values of P, L and H are dependent on both the values of rs1, rs2 as well as the given operation, following the rule outlined in the <a href="#riscv_i_tick">RISC-V I vs I'</a> chapter.<br>
            *2: For the ret variant of jalr, the target index of rd used for the writeback into the register file is ra while the target value is only the color bit in the index field with everything else being zero.
        </p>
    </section>



    
    <h1><a id="chap_refs">References</a></h1>
    <div class="references">
        <cite id="meyer_orisc">M.Meyer: "A Novel Processor Architecture with Exact Tag-Free Pointers" in Proceedings of the 2nd Workshop on Application Specific Processors., 2003.</cite>
        <cite id="llvm_gep">https://llvm.org/docs/LangRef.html#getelementptr-instruction, Last accessed 09.03.2025</cite>
    </div>

    <h1><a id="appendix">Appendix</a></h1>
    <h2><a id="boot">Boot Process</a></h2>
    <section>
        <p>
            After system reset, all registers are initialised with the value zero. Also, both <em>malc</em> and <em>msad</em> contain the value 0x0.0x0.
            The subarchitectural registers that contain the current code object length and index are also zero.
            The code object initially executed is 0x7, so its header should be located at address zero and instructions should start at address 0xC. 
            To set up this register as well as gp, a system software should start with the following instruction sequence:
        </p>

        <code><br>
            0x7.0x0:  li      t0, 0b111 # create pointer to codeobject at address zero<br>
            0x7.0x4:  dtp     t0, t0, zero # turn the value into a pointer <br>
            0x7.0x8:  jalr    zero, t0, 12  # jump in there (should jump to the instruction just after this jalr)<br>
        </code>

        <p>
            After this, it is recommended to set both <em>malc</em> as well as <em>msad</em> to reasonable values using the csrw instruction.
            Since the processor starts up in the irregular state, this should be followed by an alc or alci instruction to get into regular state and be able to call functions.
        </p>
    </section>
    <h2><a id="implemenation_notes_chap">Implementation notes</a></h2>
    <p>
        The provided behaviour of the example of an RISC-ViO implementation can be further specified. This list provides a incomplete list of recommendations for such an implementation:
        <ol>
            <li>The dtp instruction should only load the header of a pointer if a valid pointer is specified via the rs1 register. Otherwise, the header and length fields in the pipeline should be set to 0.</li>

          </ol> 
    </p>
    <h2><a id="abbrevs_gloss">Glossary and Abbreviations</a></h2>
    <ol>
        <li>XLEN - base integer ISA width (i.e. 32 for RV32)</li>
        <li>index - object field offset contained in a pointer</li>
        <li>offset - object fieöd offset being part of an instruction </li>
    </ol>
</body>

<script>
    var h1Toc = document.getElementById('toc'); 
    var headerList = document.querySelectorAll("h1, h2");

    var lastWasH2 = false;
    var toc = h1Toc;
    var h1Numbering = 0;
    var h2Numbering = 0;
    for (var i = 0; i < headerList.length; i++) {
        var header = headerList[i];
        if (header.childNodes.length == 0 || header.childNodes[0].nodeName != "A")
            continue;

        if (h2Numbering == 0 && header.nodeName == "H2"){
            const h2Toc = document.createElement("ul");
            h2Toc.style.paddingInlineStart = "28pt";
            h2Toc.style.listStyleType = "none";
            h2Toc.style.marginLeft = 0;
            h1Toc.appendChild(h2Toc);
            toc = h2Toc;
        } else if (h2Numbering > 0 && header.nodeName == "H1"){
            toc = h1Toc;
            h2Numbering = 0;
        }

        if (header.nodeName == "H1")
            h1Numbering++;
        
        if (header.nodeName == "H2")
            h2Numbering++;

        const li = document.createElement("li");
        li.className = "toc";
        if (h2Numbering == 0){
            li.style.fontSize = "14pt";
            li.style.fontWeight = "bold";
            li.appendChild(document.createTextNode(h1Numbering + ". "));
        } else {
            li.style.fontSize = "12pt";
            li.style.fontWeight = "normal";
            //li.appendChild(document.createTextNode(h1Numbering + "." + h2Numbering + ". "));
        }
        const link = header.childNodes[0].cloneNode(true);
        link.setAttribute("href", "#" + link.getAttribute("id"));
        link.setAttribute("class", "sl");
        link.setAttribute("id", null);
        li.appendChild(link);
        toc.appendChild(li);
    }
</script>
</html>