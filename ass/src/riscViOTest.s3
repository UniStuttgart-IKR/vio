.globl core.start


@core>
start
init
private
start:      la      x3, @core
            ccp     x3, x3
            jalr    ra, @core.init(x3)
            nop
            nop

init:     
            li      frame, 0x805
            la      t0, @core.exc_handel
            csrw    mtvec, t0

            li      t1, 0x01020304
            li      t2, 0x8005
            li      t3, 0x86

            push    1,7
            sp      ra, 0(frame)
            sp      x3, 0(frame)
            sw      t1, 0(frame)
            sh      t2, 4(frame)
            sb      t3, 6(frame)

            lbu     a5, 6(frame)
            lb      a4, 6(frame)
            lhu     a3, 4(frame)
            lh      a2, 4(frame)
            lw      a1, 0(frame)
            lp      a0, 0(frame)
            lp      ra, 0(frame)



            # Device 1
            li      t1, 1
            # 3 Registers, register capability
            li      t2, 3 * 2 + 0
            ciop    a1, t1, t2
            
            la      a0, hello_world_str
            #TODO: find a nicer way to do this
            addi    a0, a0, -8 #<- This is (or at least should be) done by the ccp instruction
            ccp     a0, a0
            
            jal     out_str

          
            nop
            nop
            ebreak


            push    1,0
            sp      ra, 0(frame)

            la      a0, @hdmi
            ccp     a0, a0

            la      s0, @usb
            ccp     s0, s0
            mv      s1, s0
            sp      s1, 0(frame)

            jalr    ra, @usb.af(s0)

            lp      s0, 0(frame)
            jalr    ra, @usb.b(s0)

            ebreak

# output string in object a0 via io obj in a1
out_str:    beq     a0, zero, .done
            qdtb    t0, a0
            beq     t0, zero, .done
            li      t1, 0
.outloop:   lbu.r    t2, t1(a0)
            #TODO: change the index back to 0 for output 
            sb      t2, 0(a1)
            addi    t1, t1, 1
            bne     t1, t0, .outloop
.done:
            ret


# output zero terminated string no a2 in object a0 via io obj in a1
out_str_zero:   beq     a0, zero, .donez
                qdtb    t0, a0
                beq     t0, zero, .donez
                li      t1, 0
                addi    a2, a2, 1

.srcloop:       lbu.r   t2, t1(a0)
                bne     t2, zero, .notzero
                addi    a2, a2, -1 
                addi    t1, t1, 1
                beq     a2, zero, .outloop
                addi    t1, t1, -1
.notzero:       addi    t1, t1,  1
                j       .srcloop


.outloopz:      lbu.r    t2, t1(a0)
                #TODO: change the index back to 0 for output 
                sb      t2, 0(a1)
                addi    t1, t1, 1
                bne     t2, zero, .outloopz
.donez:
                ret


exc_handel:
                nop
                nop
                nop
                # Device 1
                li      t1, 1
                # 3 Registers, register capability
                li      t2, 3 * 2 + 0
                ciop    a1, t1, t2

                la      a0, exception_hdr_str
                addi    a0, a0, -8 
                ccp     a0, a0
                jal     out_str


                la      a0, exception_strs
                addi    a0, a0, -8 
                ccp     a0, a0
                csrr    a2, mcause
                jal     out_str_zero

                nop
                nop 
                nop
                nop
                mret
                # test instr abort
                addi    t0, t0, -5
                addi    t1, t1, -9


@usb>
af
b
private

af:         addi    t0, t1,2
            addi    t3, t4,5
            ret                 #standard risc-v pseudo-instruction for jalr zero, 0(ra)

b:          push    0,0
            sp      ra, 0(frame)
            jal     c
            lp      ra, 0(frame)
            pop
            ret                 #standard risc-v pseudo-instruction for jr zero, 0(ra)

c:          push    0,0
            sp      ra, 0(frame)
            jalr    ra, @hdmi.s(a0)
            lp      ra, 0(frame)
            pop
            ret                 #standard risc-v pseudo-instruction for jr zero, 0(ra)


exception_hdr_str: object
            .ascii "An Exception occured: "

exception_strs: object
            .asciz "panic - severe internal error"
            .asciz "illeg - illegal instruction"
            .asciz "sverr - supervisor error"
            .asciz "sterr - state error"
            .asciz "privv - privilegded instruction"
            .asciz "tcoil - target code index"
            .asciz "tciob - target code index out of bound"
            .asciz "endoc - end of code"
            .asciz "rixeq - return index is zero"
            .asciz "rcdnu - return code is null"
            .asciz "rcdnc - return code ptr is not a code ptr"
            .asciz "drfnu - dereferenced null pointer"
            .asciz "drfcd - dereferenced code pointer"
            .asciz "wrptv - wrote using read only pointer"
            .asciz "sealv - wrote to read only object"
            .asciz "ixoob - index out of bounds"
            .asciz "frtyp - frame type"
            .asciz "aperr - ???"
            .asciz "hpovf - heap full"
            .asciz "stovf - stack overflow"
            .asciz "ptari - ???"


hello_world_str: object
            .ascii "Hello from RiscViO!\n"


@hdmi>
s
private

s:          addi    t0, t1,2
            addi    t3, t4,5
            ret                 #standard risc-v pseudo-instruction for jr zero, 0(ra)


