--
-- VHDL Architecture riscvio_lib.riscvio.struct
--
-- Created:
--          by - rbnlux.ckoehler (pc037)
--          at - 17:10:44 05/08/24
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2022.3 Built on 14 Jul 2022 at 13:56:12
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
LIBRARY riscvio_lib;
USE riscvio_lib.isa.all;


ARCHITECTURE struct OF riscvio IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL alu_mode_ex    : alu_mode_T;
   SIGNAL alu_out_at     : word_T;
   SIGNAL alu_out_ex_u   : word_T;
   SIGNAL alu_out_me     : word_T;
   SIGNAL ctrl_at        : ctrl_sig_T;
   SIGNAL ctrl_dc_u      : ctrl_sig_t;
   SIGNAL ctrl_ex        : ctrl_sig_T;
   SIGNAL ctrl_me        : ctrl_sig_T;
   SIGNAL current_pc_d   : word_T;
   SIGNAL falsesig       : boolean;
   SIGNAL if_instr       : word_T;
   SIGNAL if_instr_d     : word_T;
   SIGNAL imm_as_reg     : reg_T;
   SIGNAL incremented_pc : word_T;
   SIGNAL pc_current_pc  : word_T;
   SIGNAL rd_ix          : reg_ix_T;
   SIGNAL reg_rd_at      : reg_T;
   SIGNAL reg_rd_dc_u    : reg_T;
   SIGNAL reg_rd_ex      : reg_T;
   SIGNAL reg_rd_me      : reg_T;
   SIGNAL reg_rd_wb      : reg_T;
   SIGNAL reg_rs1_at     : reg_T;
   SIGNAL reg_rs1_data   : word_T;
   SIGNAL reg_rs1_dc_u   : reg_T;
   SIGNAL reg_rs1_ex     : reg_T;
   SIGNAL reg_rs1_me     : reg_T;
   SIGNAL reg_rs2        : reg_T;
   SIGNAL reg_rs2_at     : reg_T;
   SIGNAL reg_rs2_data   : word_T;
   SIGNAL reg_rs2_dc_u   : reg_T;
   SIGNAL reg_rs2_ex     : reg_T;
   SIGNAL reg_rs2_me     : reg_T;
   SIGNAL rs1_ix         : reg_ix_T;
   SIGNAL rs2_ix         : reg_ix_T;


   -- Component Declarations
   COMPONENT alu
   PORT (
      a       : IN     word_T ;
      b       : IN     word_T ;
      mode    : IN     alu_mode_T ;
      alu_out : OUT    word_T ;
      flags   : OUT    alu_flags_T 
   );
   END COMPONENT;
   COMPONENT at_reg
   PORT (
      alu_out_at : IN     word_T ;
      clk        : IN     std_logic ;
      ctrl_at    : IN     ctrl_sig_T ;
      reg_rd_at  : IN     reg_T ;
      reg_rs1_at : IN     reg_T ;
      reg_rs2_at : IN     reg_T ;
      res_n      : IN     std_logic ;
      reg_rd_wb  : OUT    reg_T 
   );
   END COMPONENT;
   COMPONENT dc_reg
   PORT (
      clk          : IN     std_logic ;
      ctrl_dc_u    : IN     ctrl_sig_t ;
      reg_rd_dc_u  : IN     reg_T ;
      reg_rs1_dc_u : IN     reg_T ;
      reg_rs2_dc_u : IN     reg_T ;
      res_n        : IN     std_logic ;
      alu_mode_ex  : OUT    alu_mode_T ;
      ctrl_ex      : OUT    ctrl_sig_T ;
      reg_rd_ex    : OUT    reg_T ;
      reg_rs1_data : OUT    word_T ;
      reg_rs1_ex   : OUT    reg_T ;
      reg_rs2_data : OUT    word_T ;
      reg_rs2_ex   : OUT    reg_T 
   );
   END COMPONENT;
   COMPONENT decoder
   PORT (
      instruction : IN     word_T;
      ctr_sig     : OUT    ctrl_sig_t;
      imm_as_reg  : OUT    reg_T;
      rd_ix       : OUT    reg_ix_T;
      rs1_ix      : OUT    reg_ix_T;
      rs2_ix      : OUT    reg_ix_T
   );
   END COMPONENT;
   COMPONENT ex_reg
   PORT (
      alu_out_ex_u : IN     word_T ;
      clk          : IN     std_logic ;
      ctrl_ex      : IN     ctrl_sig_T ;
      reg_rd_ex    : IN     reg_T ;
      reg_rs1_ex   : IN     reg_T ;
      reg_rs2_ex   : IN     reg_T ;
      res_n        : IN     std_logic ;
      alu_out_me   : OUT    word_T ;
      ctrl_me      : OUT    ctrl_sig_T ;
      reg_rd_me    : OUT    reg_T ;
      reg_rs1_me   : OUT    reg_T ;
      reg_rs2_me   : OUT    reg_T 
   );
   END COMPONENT;
   COMPONENT if_reg
   PORT (
      clk        : IN     std_logic ;
      if_instr_d : IN     word_T ;
      res_n      : IN     std_logic ;
      if_instr   : OUT    word_T 
   );
   END COMPONENT;
   COMPONENT imm_mux
   PORT (
      ctrl_dc_u    : IN     ctrl_sig_t ;
      imm_as_reg   : IN     reg_T ;
      reg_rs2      : IN     reg_T ;
      reg_rs2_dc_u : OUT    reg_T 
   );
   END COMPONENT;
   COMPONENT instruction_memory
   PORT (
      addr  : IN     word_T;
      clk   : IN     std_logic;
      instr : OUT    word_T;
      stall : OUT    boolean
   );
   END COMPONENT;
   COMPONENT me_reg
   PORT (
      alu_out_me : IN     word_T ;
      clk        : IN     std_logic ;
      ctrl_me    : IN     ctrl_sig_T ;
      reg_rd_me  : IN     reg_T ;
      reg_rs1_me : IN     reg_T ;
      reg_rs2_me : IN     reg_T ;
      res_n      : IN     std_logic ;
      alu_out_at : OUT    word_T ;
      ctrl_at    : OUT    ctrl_sig_T ;
      reg_rd_at  : OUT    reg_T ;
      reg_rs1_at : OUT    reg_T ;
      reg_rs2_at : OUT    reg_T 
   );
   END COMPONENT;
   COMPONENT next_pc_mux
   PORT (
      dbta_valid        : IN     boolean;
      dynamic_branch_pc : IN     word_T;
      incremented_pc    : IN     word_T;
      sbta_valid        : IN     boolean;
      static_branch_pc  : IN     word_T;
      next_pc           : OUT    word_T
   );
   END COMPONENT;
   COMPONENT pc_incrementer
   PORT (
      pc      : IN     word_T;
      next_pc : OUT    word_T
   );
   END COMPONENT;
   COMPONENT pc_reg
   PORT (
      clk           : IN     std_logic ;
      current_pc_d  : IN     word_T ;
      res_n         : IN     std_logic ;
      pc_current_pc : OUT    word_T 
   );
   END COMPONENT;
   COMPONENT register_file
   PORT (
      clk           : IN     std_logic;
      reg_rd_index  : IN     reg_ix_T;
      reg_rd_wb     : IN     reg_T;
      reg_rs1_index : IN     reg_ix_T;
      reg_rs2_index : IN     reg_ix_T;
      res_n         : IN     std_logic;
      reg_rd        : OUT    reg_T;
      reg_rs1       : OUT    reg_T;
      reg_rs2       : OUT    reg_T
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : alu USE ENTITY riscvio_lib.alu;
   FOR ALL : at_reg USE ENTITY riscvio_lib.at_reg;
   FOR ALL : dc_reg USE ENTITY riscvio_lib.dc_reg;
   FOR ALL : decoder USE ENTITY riscvio_lib.decoder;
   FOR ALL : ex_reg USE ENTITY riscvio_lib.ex_reg;
   FOR ALL : if_reg USE ENTITY riscvio_lib.if_reg;
   FOR ALL : imm_mux USE ENTITY riscvio_lib.imm_mux;
   FOR ALL : instruction_memory USE ENTITY riscvio_lib.instruction_memory;
   FOR ALL : me_reg USE ENTITY riscvio_lib.me_reg;
   FOR ALL : next_pc_mux USE ENTITY riscvio_lib.next_pc_mux;
   FOR ALL : pc_incrementer USE ENTITY riscvio_lib.pc_incrementer;
   FOR ALL : pc_reg USE ENTITY riscvio_lib.pc_reg;
   FOR ALL : register_file USE ENTITY riscvio_lib.register_file;
   -- pragma synthesis_on


BEGIN
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 1 eb1
   -- eb1 1      
   falsesig <= false;                                


   -- Instance port mappings.
   alu_i : alu
      PORT MAP (
         a       => reg_rs1_data,
         b       => reg_rs2_data,
         mode    => alu_mode_ex,
         alu_out => alu_out_ex_u,
         flags   => OPEN
      );
   at_reg_i : at_reg
      PORT MAP (
         alu_out_at => alu_out_at,
         clk        => clk,
         ctrl_at    => ctrl_at,
         reg_rd_at  => reg_rd_at,
         reg_rs1_at => reg_rs1_at,
         reg_rs2_at => reg_rs2_at,
         res_n      => res_n,
         reg_rd_wb  => reg_rd_wb
      );
   dc_reg_i : dc_reg
      PORT MAP (
         clk          => clk,
         ctrl_dc_u    => ctrl_dc_u,
         reg_rd_dc_u  => reg_rd_dc_u,
         reg_rs1_dc_u => reg_rs1_dc_u,
         reg_rs2_dc_u => reg_rs2_dc_u,
         res_n        => res_n,
         alu_mode_ex  => alu_mode_ex,
         ctrl_ex      => ctrl_ex,
         reg_rd_ex    => reg_rd_ex,
         reg_rs1_data => reg_rs1_data,
         reg_rs1_ex   => reg_rs1_ex,
         reg_rs2_data => reg_rs2_data,
         reg_rs2_ex   => reg_rs2_ex
      );
   decoder_i : decoder
      PORT MAP (
         instruction => if_instr,
         ctr_sig     => ctrl_dc_u,
         rs1_ix      => rs1_ix,
         rs2_ix      => rs2_ix,
         rd_ix       => rd_ix,
         imm_as_reg  => imm_as_reg
      );
   ex_reg_i : ex_reg
      PORT MAP (
         alu_out_ex_u => alu_out_ex_u,
         clk          => clk,
         ctrl_ex      => ctrl_ex,
         reg_rd_ex    => reg_rd_ex,
         reg_rs1_ex   => reg_rs1_ex,
         reg_rs2_ex   => reg_rs2_ex,
         res_n        => res_n,
         alu_out_me   => alu_out_me,
         ctrl_me      => ctrl_me,
         reg_rd_me    => reg_rd_me,
         reg_rs1_me   => reg_rs1_me,
         reg_rs2_me   => reg_rs2_me
      );
   if_reg_i : if_reg
      PORT MAP (
         clk        => clk,
         if_instr_d => if_instr_d,
         res_n      => res_n,
         if_instr   => if_instr
      );
   imm_mux_i : imm_mux
      PORT MAP (
         ctrl_dc_u    => ctrl_dc_u,
         imm_as_reg   => imm_as_reg,
         reg_rs2      => reg_rs2,
         reg_rs2_dc_u => reg_rs2_dc_u
      );
   instruction_memory_i : instruction_memory
      PORT MAP (
         clk   => clk,
         addr  => current_pc_d,
         instr => if_instr_d,
         stall => OPEN
      );
   me_reg_i : me_reg
      PORT MAP (
         alu_out_me => alu_out_me,
         clk        => clk,
         ctrl_me    => ctrl_me,
         reg_rd_me  => reg_rd_me,
         reg_rs1_me => reg_rs1_me,
         reg_rs2_me => reg_rs2_me,
         res_n      => res_n,
         alu_out_at => alu_out_at,
         ctrl_at    => ctrl_at,
         reg_rd_at  => reg_rd_at,
         reg_rs1_at => reg_rs1_at,
         reg_rs2_at => reg_rs2_at
      );
   next_pc_mux_i : next_pc_mux
      PORT MAP (
         incremented_pc    => incremented_pc,
         static_branch_pc  => incremented_pc,
         dynamic_branch_pc => incremented_pc,
         dbta_valid        => falsesig,
         sbta_valid        => falsesig,
         next_pc           => current_pc_d
      );
   pc_increment_i : pc_incrementer
      PORT MAP (
         pc      => pc_current_pc,
         next_pc => incremented_pc
      );
   pc_reg_i : pc_reg
      PORT MAP (
         clk           => clk,
         current_pc_d  => current_pc_d,
         res_n         => res_n,
         pc_current_pc => pc_current_pc
      );
   register_file_i : register_file
      PORT MAP (
         clk           => clk,
         res_n         => res_n,
         reg_rd_index  => rd_ix,
         reg_rs1_index => rs1_ix,
         reg_rs2_index => rs2_ix,
         reg_rd        => reg_rd_dc_u,
         reg_rs1       => reg_rs1_dc_u,
         reg_rs2       => reg_rs2,
         reg_rd_wb     => reg_rd_wb
      );

END struct;
