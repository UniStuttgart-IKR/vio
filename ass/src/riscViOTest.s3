.globl core.start


@core>
start
init
private
start:      la      x3, @core
            ccp     x3, x3
            jalr    ra, @core.init(x3)

init:       li      frame, 0x805
            la      t0, @core.exc_handel
            csrw    mtvec, t0
            
            la      s0, @uart
            ccp     s0, s0
            la      s1, demo_strings
            ccp     s1, s1

            li      s6, 0x08
            li      s7, '\r'
            li      s8, 48
            li      s9, 57
            la      s10, @util
            ccp     s10, s10
            
            mv      a0, s1
            jalr    ra, @uart.stringOut(s0)

repeat:     mv      a0, s1
            li      a1, 1
            jalr    ra, @uart.stringElOut(s0)

            li      s2, 0
            li      s3, 0
.sizeloop:  jalr    ra, @uart.charIn(s0)
            beq     a0,s7,.sizeEntered
            blt     a0,s8,.sizeloop
            bgt     a0,s9,.sizeloop
            bne     a0,s6,.sizeNotBs
            
            beqz    s0,.sizeloop
            addi    s2, s2,-1
            li      a0, 0x8
            jalr    ra, @uart.charOut(s0)
            li      a0, ' '
            jalr    ra, @uart.charOut(s0)
            li      a0, 0x8
            jalr    ra, @uart.charOut(s0)
            j       .sizeloop
            
.sizeNotBs: jalr    ra, @uart.charOut(s0)
            sub     a3, a0,s8
            mv      a0, s3
            li      a1, 10
            jalr    ra, @util.mul_(s10)
            add     s3, a2,a3
            j       .sizeloop

.sizeEntered:
            mv      a0, s1
            li      a1, 2
            jalr    ra, @uart.stringElOut(s0)
            slli    s3, s3,2
            la      s2, fibo_string
            ccp     s2, s2
            lbu.r   a0, s3(s2)
            jalr    ra, @uart.charOut(s0)
            addi    s3, s3,1
            lbu.r   a0, s3(s2)
            jalr    ra, @uart.charOut(s0)
            addi    s3, s3,1
            lbu.r   a0, s3(s2)
            jalr    ra, @uart.charOut(s0)
            addi    s3, s3,1
            lbu.r   a0, s3(s2)
            jalr    ra, @uart.charOut(s0)

doom:       j       repeat
            


exc_handel:     
            # Device 1
            li      t1, 1
            # 3 Registers, register capability
            li      t2, 3 * 2 + 0
            ciop    a1, t1, t2
            la      s0, @uart
            ccp     s0, s0
            la      a0, exception_hdr_str
            ccp     a0, a0
            jalr    ra, @uart.stringOut(s0)
            la      a0, exceptionStrs
            ccp     a0, a0
            csrw    mcause, a1
            jalr    ra, @uart.stringElOut(s0)
            li      a0, '\n'
            jalr    ra, @uart.charOut(s0)
            li      a0, '\r'
            jalr    ra, @uart.charOut(s0)

            ebreak
            j       repeat
            
            mret



demo_strings: object
            .asciz "Fibonacci Example"
            .asciz "\n\rEnter Index: "
            .asciz "\n\rValue is: "
            

fibo_string: object
            .asciz "000"
            .asciz "001"
            .asciz "001"
            .asciz "002"
            .asciz "003"
            .asciz "005"
            .asciz "008"
            .asciz "013"
            .asciz "021"
            .asciz "034"
            .asciz "055"
            .asciz "089"
            .asciz "144"
            .asciz "233"
            .asciz "377"
            .asciz "610"
            .asciz "987"

exception_hdr_str: object
            .ascii "\n\rAn Exception occured: "

exceptionStrs: object
            .asciz "panic - severe internal error"
            .asciz "illeg - illegal instruction"
            .asciz "sverr - supervisor error"
            .asciz "sterr - state error"
            .asciz "privv - privilegded instruction"
            .asciz "tcoil - target code index"
            .asciz "tciob - target code index out of bound"
            .asciz "endoc - end of code"
            .asciz "rixeq - return index is zero"
            .asciz "rcdnu - return code is null"
            .asciz "rcdnc - return code ptr is not a code ptr"
            .asciz "drfnu - dereferenced null pointer"
            .asciz "drfcd - dereferenced code pointer"
            .asciz "wrptv - wrote using read only pointer"
            .asciz "sealv - wrote to read only object"
            .asciz "ixoob - index out of bounds"
            .asciz "frtyp - frame type"
            .asciz "aperr - ???"
            .asciz "hpovf - heap full"
            .asciz "stovf - stack overflow"
            .asciz "ptari - arithmetic on pointer register"
            .word  0


hello_world_str: object
            .ascii "Hello from RiscViO!\n\r"

@uart>
charIn
charOut
stringElOut
stringOut
private

charOut:    li      t1, 1
            li      t2, 3 * 2 + 0
            ciop    t0, t1, t2
            sb      a0, 0(t0)
            ret

charIn:     li      t1, 1
            li      t2, 3 * 2 + 0
            ciop    t0, t1, t2
            lbu     a0, 0(t0)
            ret


stringElOut:
            mv      a7, a0
            qdtb    a6, a7
            li      a5, -4
            li      a4, 0

.next:      addi    a5, a5,4
            bge     a5,a6,.oob
            lw.r    t1, a5(a7)  #CAFFE00FF
            orc.b   t1, t1      #BBBBB00BB
            not     t1, t1      #00000BB00
.again:     beqz    t1, .next
            #found a chunk with at leat one zero byte
            ctz     t2, t1
            addi    t2, t2,8
            srl     t1, t1,t2
            addi    a4, a4,1
            bne     a4,a1,.again
            srli    t2, t2,3
            add     a1, a5,t2
            j       stringOutInt

.oob:       li      a1, -1
            ret

stringOut:  li      a1, 0
            mv      a7, a0
            qdtb    a6, a7

stringOutInt:
            push    0,0
            sp      ra, 0(frame)

.nxt:       beq     a1,a6,.end
            nop
            lbu.r   a0, a1(a7)
            beqz    a0, .end
            jal     charOut
            addi    a1, a1,1
            j       .nxt

.end:       lp      ra, 0(frame)
            pop
            ret

@util>
mul_
divu_
private
#mul a2, a1,a0
mul_:       mv      a2, zero
mul_loop:   beqz    a1, util.mul_end
            add     a2, a2,a0
            addi    a1, a1,-1
            j       mul_loop
mul_end:    ret


#takes:		a0 = dividend, a1 = divisor
#returns:	a0 = quotient, a1 = rest
divu_:		beqz	a1,util.divu_end    #TODO: fix this
			li	    t2, 32			#counter
			clz		t1, a0			#leading zeros
			sub		t2, t2,t1   	#remaining counter (may be 0) 
			sll		a0, a0,t1
			li      t1, 0           #AC
			beqz    t2, util.divu_done
divu_loop:	rori	t0, a0,31
            and		t0, t0,1		#Bit 31 alter Dividend
			slli   	a0, a0,1		#Dividend << 1
            slli   	t1, t1,1		#AC << 1
			or		t1, t1,t0
			bltu	t1,a1,util.divu_nope
			sub		t1, t1,a1
			addi    a0, a0,1
divu_nope: 	addi    t2, t2,-1
			bnez    t2, util.divu_loop
divu_done:	mv		a1, t1
divu_end:   ret

