<!DOCTYPE html>
<html lang="en">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="misc/ieee.css">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RISC-ViO Spec</title>
</head>
<body>
    <header class="col-span page-break-after">
        <div class="subtitle counter-skip" style="margin-bottom: 0;"><em>The</em></div>
        <div class="title counter-skip"><em>RISC-ViO</em></div>
        <div class="subtitle counter-skip"><em>Specification</em></div>
        <h2 class="subtitle counter-skip"><em>Draft V0.0.1</em></h2>
        <div class="authors col-2">
        <div class="author">
            <div>Leyla Jazz Ekinci (<em>B.Sc.</em>)</div>
            <div>University of Stuttgart, IKR</div>
            <div>Stuttgart, Germany</div>
            <div>email</div>
        </div>
        <div class="author">
            <div>Robin Lux (<em>B.Sc.</em>)</div>
            <div>University of Stuttgart, IKR</div>
            <div>Stuttgart, Germany</div>
            <div>email</div>
        </div>
        </div>
    </header>

    <h1 class="counter-skip page-break-before" style="text-align: center;">Table of Contents</h1>
    <ul id="toc" class="toc page-break-after" style="list-style-type:none; margin-left: 0;">
    </ul>

    <h1><a id="motivation">Motivation</a></h1>
    <section>
      <p>(max halbe seite, 2 bildchen konventionell vs objektorientiert)</p>
    </section>

    <h1><a id="base_spec">Changes to the RISC-V base instructions</a></h1>
    <section>
      <p>- pointer vs daten (addi vs alci)<br>
         - Wie unterscheiden sich load/store befehle von herk√∂mmlichen risc-v prozessoren
        - regular vs data only objects
    </p>
    </section>

    <h1><a id="instructions">The Zhm Extension</a></h1>
        <p>In addition to the modifications of already existing instructions which are part of the RISC-V I base ISA, RISC-ViO introduces several instructions as an interface between software and hardware regarding objects.
            Those instructions are all part of the zhm extension.
        </p>
    <section>
        <h2><a name="unpriv_instructions">Unprivileged Instructions</a></h2>
        <h3><a name="alc_fam">Allocation: alc/alci/alc.d/alci.d</a></h3>
        Since RISC-ViO manages objects on the ISA level, the ISA has to provide a means to create new objects and their corresponding pointers.
        This creation of ISA level objects is achieved by the alc-Instruction family which comes in four flavours. 
        The next section provides an short description with those instructions alongside their bit encodings.

        <h4><a name="alci">alci-Instruction</a></h4>
        The alci instruction is the most basic form in its family. This instruction allows the allocation of a regular object
        <div style="width: 100%; display: flex; justify-content: center;">
            <div style="width: 80%; display: flex; justify-content: space-around; flex-direction: row;  flex-wrap: wrap;">
                <img src="svg/alci_instr_bitmap.svg" id="svg2" style="width: 80%; margin: 0px auto;">
            </div>
        </div>
        <h4><a name="alc">alc-Instruction</a></h4>
            The alc instruction is a variation of the alci instruction. In contrast to alci, the size of the new object is given by the content of register rs1.
            Apart from the source of the object size, alc only differs from alci in that alc cannot be used to allocate a stack frame. 
        <div style="width: 100%; display: flex; justify-content: center;">
            <div style="width: 80%; display: flex; justify-content: space-around; flex-direction: row;  flex-wrap: wrap;">
                <img src="svg/alc_instr_bitmap.svg" id="svg3" style="width: 80%; margin: 0px auto; color-scheme: light;">
            </div>
        </div>
        <h4><a name="alcid">alcid-Instruction</a></h4>
            TODO
        <div style="width: 100%; display: flex; justify-content: center;">
            <div style="width: 80%; display: flex; justify-content: space-around; flex-direction: row;  flex-wrap: wrap;">
                <img src="svg/alcid_instr_bitmap.svg" id="svg2" style="width: 80%; margin: 0px auto; background-color: #FFFFFF;">
            </div>
        </div>
        <h4><a name="alcd">alcd-Instruction</a></h4>
            TODO
        <div style="width: 100%; display: flex; justify-content: center;">
            <div style="width: 80%; display: flex; justify-content: space-around; flex-direction: row;  flex-wrap: wrap;">
                <img src="svg/alcd_instr_bitmap.svg" id="svg2" style="width: 80%; margin: 0px auto; background-color: #FFFFFF;">
            </div>
        </div>
        <h3><a name="qsz">Attribute Query: qsz</a></h3>
        <h2><a name="priv_instructions">Privileged Instructions</a></h2>
        <h3><a name="dtp">Raw Pointer Access: dtp/btd/itd</a></h3>
        <h3><a name="lw_x">Raw Memory Access: lw.x/sw.x</a></h3>
    </section>

    <h1><a name="objects">Objects</a></h1>
    <section>
    </section>
    
    <h1><a name="frames">The not so stacked frames</a></h1>

        <h2><a name="are_obj">Structure</a></h2>
        <h2><a name="cc">Calling Convention</a></h2>
        <section>
            <h2><a name="protection">Frame Ownership</a></h2>
                <p>//trivia about how accesses beyond stack frames are bad//</p>
                <p>In order to protect the stack frame of a function from modification by other functions, RISC-ViO introduces a scheme to protect these frames.
                This requires access management for those frames, which RISC-ViO implements in form of adding colour tags to both the sp as well as the ra register.
                By updating those colours at critical points such as function entries and frame allocations, the processor always knows whether the stack frame pointed to by the
                sp register is owned by the currently executed function. 
                This state is called "regular", while the current function not being the owner of the current stack frame is denoted as the "irregular" state.
                </p>
                <p>For sp as well as for ra, there are two colours: black and white. Those colours are an integral part of those registers and cannot be read or modified seperately from their registers.
                Also, when storing/loading ra or sp using sw/lw, the colour is also stored/retrieved to/from the given memory location.
                    An overview of the transition between those colours is given in Figure 1.
                    On every function entry, the processor flips the colour of ra from white to black or vice-versa. For sp, this takes place on every stack frame allocation.
                    Whether the processor is currently in the regular state is given by the equality of the colours of ra and sp. 
                    If the colours of sp and ra both were black for example, the processor would be in the regular state.
                </p>
            <figure>
                <figcaption>Colour transitions</figcaption>
                <div style="width: 100%; display: flex; justify-content: center;">
                    <div style="width: 80%; display: flex; justify-content: space-around; flex-direction: row;  flex-wrap: wrap;">
                        <div style="margin: 0px auto" >
                            <img src="svg/vio_stack_colors_transitions.drawio.svg" id="svg2" style="width: 20rem; margin: 0px auto;">
                        </div>
                    </div>
                </div>
            </figure>
                <p>
                    Figure 2 provides two sample program flows for which the colour and therefore state transitions are shown. 
                    Figure 2a) shows the behaviour of the colour mechanism during the execution of a correct stream of instructions while figure 2b) highlights how this mechanism catches bad program behaviour and the subsequent raising of the StateException. 
                </p>
            <figure>
                <figcaption>State transitions for examplatory instruction streams</figcaption>
                <div style="display: flex; margin-top: 14pt; margin-bottom: 28pt;">
                    <img src="svg/vio_stack_colors.drawio.svg" id="svg1" style="flex: 50%; margin-right: 10pt;">
                    <img src="svg/vio_stack_colors_exception.drawio.svg" id="svg2" style="flex: 50%; margin-left: 10pt; align-self: baseline;">
                </div>
                <div style="display: flex;">
                    <p style="flex: 50%; margin-right: 10pt;">a) Transitions during normal program flow</p>
                    <p style="flex: 50%; margin-left: 10pt;">b) Transitions during abnormal program flow with exception</p>
                </div>
            </figure>
        </section>
    
    <h1><a id="got">Global Offset Table</a></h1>
    <h2><a id="gp">Global Pointer</a></h2>
    <section>
    </section>
    <h2><a id="static">Accessing static objects</a></h2>
    <section>
    </section>
    
    <h1><a id="exceptions">Exceptions</a></h1>
    <h2><a id="gen">General</a></h2>
    <section>
    </section>
    <h2><a id="priv">Privilege Violations</a></h2>
    <section>
    </section>

    <h1><a id="hard_obj">Hardwares view on Objects</a></h1>
    <h2><a id="headers">Headers</a></h2>
    <section>
    </section>
    <h2><a id="elements">Elements</a></h2>
    <section>
    </section>
    <h2><a id="ords">Ordinaries</a></h2>
    <section>
    </section>
    <h2><a id="execs">Executables</a></h2>
    <section>
    </section>
    <h2><a id="sancts">Sanctuaries</a></h2>
    <section>
    </section>

    <h1><a id="reg_fl">How a Register File could look like</a></h1>
    <h2><a id="fields">Fields</a></h2>
    <section>
    </section>
    <h2><a id="coloring">Coloring</a></h2>
    <section>
    </section>
    <h2><a id="flgs_tgs">Flags and Tags</a></h2>
    <section>
    </section>

    <h1><a id="ptr_addr">Pointer and Address generation</a></h1>
    <h2><a id="alcs">Allocations</a></h2>
    <section>
    </section>
    <h2><a id="load_store">Loading and Storing a Pointer</a></h2>
    <section>
    </section>
    <h2><a id="bounds">Bounds Checks</a></h2>
    <section>
    </section>

    <h1><a id="tables">Tables</a></h1>
    <h2><a id="t_inst">Instructions</a></h2>
    <section>
    </section>
    <h2><a id="t_op">Object and Pointer Types</a></h2>
    <section>
    </section>
    <h2><a id="t_exc">Exceptions</a></h2>
    <section>
    </section>
    <h2><a id="t_csr">CSRs</a></h2>
    <section>
    </section>
    
    <h1><a id="appendix">Appendix</a></h1>
    <h2><a id="boot">Boot Process</a></h2>
    <section>
    </section>
</body>

<script>
    var h1Toc = document.getElementById('toc'); 
    var headerList = document.querySelectorAll("h1, h2");

    var lastWasH2 = false;
    var toc = h1Toc;
    var h1Numbering = 0;
    var h2Numbering = 0;
    for (var i = 0; i < headerList.length; i++) {
        var header = headerList[i];
        if (header.childNodes.length == 0 || header.childNodes[0].nodeName != "A")
            continue;

        if (h2Numbering == 0 && header.nodeName == "H2"){
            const h2Toc = document.createElement("ul");
            h2Toc.style.paddingInlineStart = "28pt";
            h2Toc.style.listStyleType = "none";
            h2Toc.style.marginLeft = 0;
            h1Toc.appendChild(h2Toc);
            toc = h2Toc;
        } else if (h2Numbering > 0 && header.nodeName == "H1"){
            toc = h1Toc;
            h2Numbering = 0;
        }

        if (header.nodeName == "H1")
            h1Numbering++;
        
        if (header.nodeName == "H2")
            h2Numbering++;

        const li = document.createElement("li");
        li.className = "toc";
        if (h2Numbering == 0){
            li.style.fontSize = "14pt";
            li.style.fontWeight = "bold";
            li.appendChild(document.createTextNode(h1Numbering + ". "));
        } else {
            li.style.fontSize = "12pt";
            li.style.fontWeight = "normal";
            //li.appendChild(document.createTextNode(h1Numbering + "." + h2Numbering + ". "));
        }
        const link = header.childNodes[0].cloneNode(true);
        link.setAttribute("href", "#" + link.getAttribute("id"));
        link.setAttribute("class", "toc-link");
        link.setAttribute("id", null);
        li.appendChild(link);
        toc.appendChild(li);
    }
</script>
</html>