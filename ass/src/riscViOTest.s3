.globl core.start


@core>
start
init
private
start:      la      x3, @core
            ccp     x3, x3
            jalr    ra, @core.init(x3)
            nop
            nop

init:     
            li      frame, 0x805
            la      t0, @core.exc_handel
            csrw    mtvec, t0
            
            la      t0, @uart
            ccp     t0, t0
            la      a0, exceptionStrs
            ccp     a0, a0
            li      a1, 4
            jalr    ra, @uart.stringElOut(t0)

            ebreak


            # Device 1
            li      t1, 2
            # 3 Registers, register capability
            li      t2, 5 * 2 + 0
            ciop    s2, t1, t2
            li      s3, 1
            li      s4, 0x100

            # Device 1
            li      t1, 1
            # 3 Registers, register capability
            li      t2, 3 * 2 + 0
            ciop    s1, t1, t2            
            
            la      a0, hello_world_str
            ccp     s0, a0
            
.loop:      sb      s3, 0(s2)
            slli    s3, s3,1
            blt     s3,s4,.byteOk
            li      s3, 1
.byteOk:    #TODO: add .label expansion (to coobj.subroutine.label)
            #rori    s3, s3, 1
            la      t0, @uart
            mv      a0, s0
            mv      a1, s1
            jalr    ra, @uart.stringOut(t0)
            ebreak

            j       .loop


exc_handel:
                nop
                nop
                nop
                # Device 1
                li      t1, 1
                # 3 Registers, register capability
                li      t2, 3 * 2 + 0
                ciop    a1, t1, t2

                la      s0, @uart

                la      a0, exception_hdr_str
                ccp     a0, a0
                jalr    ra, @uart.stringOut(s0)


                la      a0, exceptionStrs
                ccp     a0, a0
                csrr    a2, mcause
                jalr    ra, @uart.stringOut(s0)

                nop
                nop 
                nop
                nop
                mret
                # test instr abort
                addi    t0, t0, -5
                addi    t1, t1, -9

exception_hdr_str: object
            .ascii "An Exception occured: "

exceptionStrs: object
            .asciz "panic - severe internal error"
            .asciz "illeg - illegal instruction"
            .asciz "sverr - supervisor error"
            .asciz "sterr - state error"
            .asciz "privv - privilegded instruction"
            .asciz "tcoil - target code index"
            .asciz "tciob - target code index out of bound"
            .asciz "endoc - end of code"
            .asciz "rixeq - return index is zero"
            .asciz "rcdnu - return code is null"
            .asciz "rcdnc - return code ptr is not a code ptr"
            .asciz "drfnu - dereferenced null pointer"
            .asciz "drfcd - dereferenced code pointer"
            .asciz "wrptv - wrote using read only pointer"
            .asciz "sealv - wrote to read only object"
            .asciz "ixoob - index out of bounds"
            .asciz "frtyp - frame type"
            .asciz "aperr - ???"
            .asciz "hpovf - heap full"
            .asciz "stovf - stack overflow"
            .asciz "ptari - ???"
            .word  0


hello_world_str: object
            .ascii "Hello from RiscViO!\n\r"

@uart>
stringElOut
stringOut
private

charOut:    li      t1, 1
            li      t2, 3 * 2 + 0
            ciop    t0, t1, t2
            sb      a0, 0(t0)
            ret

charIn:     li      t1, 1
            li      t2, 3 * 2 + 0
            ciop    t0, t1, t2
            lbu     a0, 0(t0)
            ret


stringElOut:
            mv      a7, a0
            qdtb    a6, a7
            li      a5, -4
            li      a4, 0

.next:      addi    a5, a5,4
            bge     a5,a6,.oob
            lw.r    t1, a5(a7)  #CAFFE00FF
            orc.b   t1, t1      #BBBBB00BB
            not     t1, t1      #00000BB00
.again:     beqz    t1, .next
            #found a chunk with at leat one zero byte
            ctz     t2, t1
            addi    t2, t2,8
            srl     t1, t1,t2
            addi    a4, a4,1
            bne     a4,a1,.again
            srli    t2, t2,3
            add     a1, a5,t2
            j       stringOutInt


.oob:       li      a1, -1
            ret

stringOut:  li      a1, 0
            mv      a7, a0
            qdtb    a6, a7

stringOutInt:
            push    0,0
            sp      ra, 0(frame)

.nxt:       beq     a1,a6,.end
            lbu.r   a0, a1(a7)
            beqz    a0, .end
            jal     charOut
            addi    a1, a1,1
            j       .nxt

.end:       lp      ra, 0(frame)
            pop
            ret
